<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识记录</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-22T05:07:46.753Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>苏生</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis</title>
    <link href="http://example.com/2022/05/13/Redis/"/>
    <id>http://example.com/2022/05/13/Redis/</id>
    <published>2022-05-13T04:48:47.000Z</published>
    <updated>2023-02-22T05:07:46.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><h2 id="什么是Redis？为什么使用Redis？"><a href="#什么是Redis？为什么使用Redis？" class="headerlink" title="什么是Redis？为什么使用Redis？"></a>什么是Redis？为什么使用Redis？</h2><p>​        Redis是一种支持多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。使用Redis主要有两个用途：高并发和高性能。当然Redis还有作为分布式锁的功能，但这可以 用其他技术代替实现。</p><ul><li><strong>高性能：</strong>我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<strong>更快响应</strong>。</li><li><strong>高并发：</strong>在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用Redis做一个缓冲操作，让请求先访问到Redis，而不是直接访问数据库。</li></ul><h2 id="Redis为什么快呢？"><a href="#Redis为什么快呢？" class="headerlink" title="Redis为什么快呢？"></a>Redis为什么快呢？</h2><ul><li><p><strong>完全基于内存操作：可以避免频繁的进行磁盘IO，大大降低响应时间</strong></p><p>MySQL 是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢，每次请求访问数据库时，都存在着 I/O 操作（磁盘IO是很消耗性能的），如果反复频繁的访问数据库，会在数据库中花费过多的时间，并且反复访问数据库会导致数据库的负载过高。</p><p>而 Redis 是基于内存的缓存数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率。</p></li><li><p><strong>使用单线程：避免了线程切换和竞态产生的消耗</strong></p><p>多线程在执行过程中需要进行 CPU 的上下文切换，需要完成一系列工作，这是非常消耗资源的操作，Redis 又是基于内存实现的，对于内存来说，没有上下文切换效率就是最高的。多次读写都在一个CPU 上，对于内存来说就是最佳方案。</p></li><li><p><strong>基于非阻塞的IO多路复用机制</strong></p><p>Redis 采用网络 IO 多路复用技术，来保证在多连接的时候系统的高吞吐量。 多路-指的是多个 socket网络连接，复用-指的是复用一个线程。 采用多路 I/O 复用技术,可以让单个线程高效处理多个连接请求（尽量减少网络 IO 的时间消耗）。并且 Redis 在内存中操作数据的速度非常快（因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈）。</p><p>主要以上两点造就Redis 具有很高的吞吐量。 采用多路 I/O复用技术可以让单个线程高效的处理多个连接请求</p></li><li><p><strong>基于几种基础的数据结构，Redis专门做了大量优化，性能极高</strong></p><p>MySQL 索引为了提高效率，选择了 B+ 树的数据结构，对于一个应用场景来说合理的数据结构可以让你的应用或者程序更快</p><p>Redis 的底层数据结构一共有6种，分别是简单动态字符串，双向链表，压缩列表，哈希表，跳表和整数数组</p><p>它们和数据类型的对应关系如下图所示：</p><p><img src="/imgs/2.png" alt="image-20230214205104776"></p></li></ul><h2 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h2><p>​        Redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。</p><p>​        它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据socket 上的事件类型来选择对应的事件处理器进行处理。</p><h2 id="Redis的常用数据类型及应用场景"><a href="#Redis的常用数据类型及应用场景" class="headerlink" title="Redis的常用数据类型及应用场景"></a>Redis的常用数据类型及应用场景</h2><p>常见的数据结构有: String、Hash、List、Sets、SortSet, 进阶的有HyperLogLog、Geo、Pub/Sub、Streams等</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>​        String 通常是以 key 和 value 的形式存储，它内部存储是一个字符数组形式。Redis 字符串的最大长度是 512M，并且的存储是动态的(意味着可以随时修改它本身的值)，每次分配内存时会高出实际字符串的 length,这样采用<strong>预分配冗余空间方式来减少内存的频繁分配</strong>。</p><h4 id="String常用命令："><a href="#String常用命令：" class="headerlink" title="String常用命令："></a><strong>String常用命令：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set    - 设置key的值；若key存在，覆盖旧值无视类型，成功返回OK(注意是大写OK，</span><br><span class="line">get    - 获取指key值；若key不存在，返回nil(不是null,不要搞错)</span><br><span class="line">mset   - 同set一致，批量设置键值对，减少网络开销</span><br><span class="line">mget   - 同get一致，批量获取键值对，减少网络开销</span><br><span class="line">incr   - key值+1，不存在则先set后incr，返回integer切记值必须能标识为数字</span><br><span class="line">incrby - 同incr一致，多出一个指定数字增量值</span><br><span class="line">decr   - 同incr原理一致，操作方式变为了减法</span><br><span class="line">decrby - 同incrby原理一致，操作方式变为了减法</span><br><span class="line">strlen - 获取长度len，若不存在返回0，类型为integer</span><br><span class="line">setnx  - 设置key值，若key不存在，则返回1，否则返回0。(若场景需要设置过期时间，不推荐使用这个命令，网络波动情况下，有可能setnx成功，expire却失败了，不是原子操作)</span><br><span class="line">setex  - 设置key值及过期时间，若key已存在，则替换旧值覆盖。(若需要set值且需设置过期时间且要求较高必须要有过期时间，推荐使用这个命令，设置key值+过期时间是原子操作，要么成功要么失败)</span><br><span class="line">append - 对key值进行末尾追加数据，返回值是字符串长度</span><br></pre></td></tr></table></figure><h4 id="String使用场景："><a href="#String使用场景：" class="headerlink" title="String使用场景："></a>String使用场景：</h4><p><strong>计数</strong>、<strong>缓存基础数据</strong>、<strong>限制请求次数</strong>、<strong>分布式下共享 session</strong>、<strong>签到</strong>等等</p><p><strong>分布式下共享 session</strong>：</p><p>系统最开始时由于用户量小一般都是<strong>单机器支撑</strong>，用户登录之后存储在 <strong>session</strong>中，那么当随着我们的业务越来越大，用户量激增到上百万，这个时候我们有单机变成了集群，使用了 <strong>Nginx 做负载均衡</strong>，将各个用户的请求都会被负载到各个服务器上，用来分摊机器压力，保证服务x稳定。</p><p>这个时候会发现用户登录时请求随机到了某一台机器，这个时候生成了 session 文件，但是在用户访问其他页面又被随机到其他服务器这个时候拿不到 session，就会被拦截用户登录请求，就导致用户可能要登录很多次。</p><p>那么这个时候分布式缓存就可以解决这个问题啦。用 Redis 将用户的 Session 信息进行集中的管理，每次用户登录信息都从 Redis 中集中获取，这样完美的解决了这一问题。</p><h3 id="List"><a href="#List" class="headerlink" title="List :"></a><strong>List :</strong></h3><p>Redis 中的 List 其实就是数据结构链表的实现。列表内部是一个双链表，这就说明列表的<strong>插入和删除操作速度很快</strong>，在插入的时候可以达到 O(1)的复杂度，但是通过索引去查找一个节点是非常慢的，时间复杂度 O(n)的时间。</p><h4 id="List常用命令"><a href="#List常用命令" class="headerlink" title="List常用命令"></a>List常用命令</h4><ul><li><strong>添加 insert 指令操作：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lpush指令：lpush key value ... 从左边插入元素(将一个或多个值插入到列表头部)；时间复杂度O(1)。</span><br><span class="line">rpush指令：rpush key value ... 从右边插入元素(将一个或多个值插入到列表的尾部(最右边))；时间复杂度O(1)。</span><br><span class="line">linsert指令：linsert key before|after pivot(指定元素) value(插入值) 向某个元素前/后插入元素，返回结果为当前列表长度，注意列表不存在或者指定元素不存在列表中时，都将不执行任何操作。时间复杂度O(n)，n为寻找指定元素中经过的元素数量。</span><br></pre></td></tr></table></figure><ul><li><strong>查找 select 指令操作：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrange指令：lrange key start end 获取列表中指定范围内的元素列表；若start值大于列表end值则返回空列表；时间复杂度O(s+n) s为偏移量start，n为指定区间元素数量。</span><br><span class="line">lindex指令：lindex key index(可负值) 获取列表指定索引下标的元素；时间复杂度O(n)，n为到达下标index过程中经过的元素数量；列表头部和尾部元素获取，时间复杂度O(1)。</span><br><span class="line">llen指令：llen key 获取列表长度；列表不存在则返回0，时间复杂度O(1)。</span><br></pre></td></tr></table></figure><p><strong>删除 delete 指令操作：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lpop指令：lpop key 从列表左侧弹出元素并返回头部元素；时间复杂度O(1)</span><br><span class="line">rpop指令：rpop key 从列表右侧弹出元素并返回尾部元素；时间复杂度O(1)</span><br><span class="line">lrem指令：lrem key count value 从列表中找到等于value的元素进行删除，根据count的不同分为三种情况，时间复杂度O(n)，n为列表的长度：</span><br><span class="line">count &gt; 0，从表头开始向表尾，移除数量为count个元素；</span><br><span class="line">count &lt; 0，从表尾开始向表头，移除数量为count的绝对值个元素；</span><br><span class="line">count = 0，移除表中所有与 value 相等的值；</span><br><span class="line">ltrim指令：ltrim key start end 按照索引范围修建列表，相当于切片操作；时间复杂度O(n)，n为被移除的元素的数量。</span><br></pre></td></tr></table></figure><ul><li><strong>修改 update 操作：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lset指令：lset key index value 修改指定下标的元素的值设置为value；时间复杂度：① 对头元素(第一个)或尾元素(最后一个)进行操作时，复杂度为O(1)。② 其他情况下，复杂度为O(n)，n为列表的长度。</span><br></pre></td></tr></table></figure><ul><li><strong>阻塞 block 指令操作：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blpop指令：blpop key [key ...多个key] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止；时间复杂度O(1)。</span><br><span class="line">brpop指令：brpop key [key....多个key] timeout 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止；时间复杂度O(1)。</span><br></pre></td></tr></table></figure><h4 id="List使用场景"><a href="#List使用场景" class="headerlink" title="List使用场景"></a>List使用场景</h4><p><strong>消息队列、延迟消息队列、关注列表、粉丝列表、人气榜单、热点新闻等等</strong></p><ul><li><strong>人气榜单+热点新闻</strong></li></ul><p>​        需求：每个月/星期会重新计算生成一份活动排行榜的列表展示。可以使用 <strong>lpush+lrange</strong> 来实现排行榜。假如我们有一个抽奖活动，展示最近 20 个抽中奖励的人，做全站高亮轮播；那么可以使用 <strong>lpush+ltrim+lrange</strong> 来实现。注意点：如果我们的数据实时更新，那么就不可以 list 列表存储，相应的要改用有序集合 <strong>sorted set</strong>实时计算榜单数据。</p><p>​        类似排行或者粉丝列表的情景；list 类型能做到的 sorted set 类型同样可以做，甚至有序集合比 list 做的更多，那么你在做热点新闻或者粉丝排行榜时是怎么考虑选择使用类型的？</p><p>​        在做热点新闻时，之所以不选择使用有序集合，最根本原因是 sorted set 类型占用的内存空间是列表的多倍。</p><p>其原因就是 list 和 sorted set 底层实现方式复杂度不同。① list 底层使用<strong>压缩列表或链表</strong>来实现，当列表对象保存的所有字符串元素的长度<strong>都小于 64 字节</strong>，并且列表对象的元素数量<strong>小于 512 字节时</strong>，list 对象使用 ziplist 编码，否则使用 linkedlist 编码；可以看出它只会使用一种编码格式。② sorted set <strong>底层使用了 ziplist</strong>(<strong>压缩</strong>)<strong>和 skiplist</strong>(<strong>跳跃表</strong>)，当元素数量<strong>小于 128</strong> 个，并且所有元素成员的长度<strong>小于 64 字节</strong>时，使用 ziplist 编码，否则使用 skiplist 编码；如果排序需要 O(nlogn)的时间复杂度，以及额外的 O(n)的内存空间。</p><p><strong>相对来说列表更适合这种固定不变化的数据存储。</strong></p><ul><li><strong>消息队列</strong></li></ul><p>市场上已经有了非常成熟的消息队列，比如RabbitMQ、RocketMQ等。那为什么还要使用 Redis 做队列呢？</p><p>主要有以下几点：1、对队列消息的要求可靠度不高，丢了就不管了。2、消息的数据量没有上千万上亿级别，Redis 完全可以支撑满足。3、公司没钱搞，需要机器，需要成本，需要人力，如果原有机器可以满足就不折腾。</p><p>通常我们会使用 <strong>rpush+lpop</strong> 来做队列，rpush 生产消息，lpop 消费消息，然后开启多进程去跑脚本处理队列，</p><p><strong>扩展：</strong></p><p><strong>面试官</strong>：那么，假如你的队列被消耗空了，但是有没有新的数据产生，就会导致脚本一直在 pop 进入死循环，这是在消耗服务器的资源，增加了 cpu 的消耗，当然 Redis 的 qps 可能也会增高，这个时候你该怎么办呢？</p><p><strong>面试者</strong>：一般我们可以在 pop 为空数据的时候，适当的增加一个 sleep 休眠期，例如 0.5s，那么这样 cpu 的消耗就会较小。</p><p><strong>面试官</strong>：那你有没有考虑到，如果 sleep 阻塞当前消息处理线程，可能会导致整个消息出现延迟；这样的话，我们又该怎么办，是否还有其他的处理方案呢？</p><p><strong>面试者</strong>：可以使用 list 的 <strong>blpop</strong>、<strong>brpop</strong> 指令来实现阻塞读取数据。当队列没有数据时，会进入休眠状态；当队列有数据来时，则唤醒过来，那么消息基本上就不会被延迟处理了。</p><ul><li><strong>延迟队列</strong></li></ul><p><strong>通俗一点的讲</strong>：延迟队列就是把队列里的消息体延迟处理，常用的场景有：<strong>订单超时取消</strong>、<strong>游戏超时检测</strong>等等</p><p>通过 push 队列数据时，<strong>给消息体增加一个 delay 到期的时间，每次 pop 出来，解析数据拿到 delay 跟当前时间戳进行对比，判断是否到期</strong>；到期则根据对应逻辑处理，否则重新丢进队列尾部进行消费，我们只需要保证消息队列能不阻塞，能正常的消费完即可。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Redis 中的哈希(hash 或者<strong>散列表</strong>)，内部存储很多键值对以 key - [<strong>Field-Value</strong>]的形式存储，也是一种<strong>数组+链表</strong>的二维结构(本身又是一个 键值对结构)。</p><h4 id="Hash常用指令"><a href="#Hash常用指令" class="headerlink" title="Hash常用指令"></a>Hash常用指令</h4><p><strong>1、查找 select 指令操作：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hget指令：hget key field 获取哈希表key中给定字段的值，不存在返回nil；时间复杂度O(1)。</span><br><span class="line">hgetall指令：hgetall key 获取哈希表key中的所有字段和值，不存在返回空列表；时间复杂度O(n)，n是哈希表的大小。</span><br><span class="line">hlen指令：hlen key 获取哈希表key中field的数量，不存在返回0；时间复杂度O(1)。</span><br><span class="line">hmget指令：hmget key [field ...] 获取哈希表key中一个或多个给定字段的值，不存在返回nil；时间复杂度O(n)，n为给定字段的数量。</span><br><span class="line">hkeys指令：hkeys key 获取哈希表key中所有字段，不存在返回空表；时间复杂度O(n)，n为哈希表的大小。</span><br><span class="line">hscan指令：hscan key cursor(游标) [MATCH pattern(匹配的模式)] [COUNT count(指定从数据集里返回多少元素，默认值为 10 )] 获取哈希表key中匹配元素。</span><br><span class="line">hvals指令：hlen key 获取哈希表key中所有的字段的值，不存在返回空表；时间复杂度O(n)，n是哈希表的大小。</span><br><span class="line">hexists指令：hexists key field 获取哈希表key中field是否存在，存在返回1不存在返回0；时间复杂度O(1)。</span><br><span class="line">hstrlen指令：hstrlen key field 获取哈希表key中字段长度，不存在返回0，否则返回长度整数；时间复杂度O(1)。</span><br></pre></td></tr></table></figure><p><strong>2、添加 insert 指令操作：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hset指令：hset key value 将哈希表key中的字段的值设为value，不存在则创建设置，否则将覆盖旧值；时间复杂度O(1)。注意点：如果哈希表中字段已经存在且旧值已被新值覆盖，返回0而不是1，不能搞错。</span><br><span class="line">hmset指令：hmset field value [field value ...] 一次将多个field-value数据设置进哈希表中，表中已存在的字段会直接覆盖；时间复杂度O(n)，n为field-value的数量。注意：不同于hset，若哈希表已存在字段值，重复设置将会返回OK，而不是0。</span><br><span class="line">hsetnx指令：hsetnx key field value 仅仅当哈希表中字段不存在时可设置，否则无效；时间复杂度O(1)。注意：跟setnx不同的是，若设置的字段已存在值，那么当前操作将返回结果集为0而不是OK。</span><br><span class="line">hincrby指令：hincrby key field increment 给哈希表中指定字段增加数值；时间复杂度O(1)。注意：执行hincrby命令后返回的是字段的最新值，而不是ok或者1。</span><br></pre></td></tr></table></figure><p><strong>3、删除 delete 指令操作：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel指令：hdel key field [field ...] 删除哈希表中一个或多个字段，不存在则忽略；时间复杂度O(n)，n为要删除字段的数量。注意：删除操作返回值是删除成功的数量，不存在的字段将被忽略。</span><br></pre></td></tr></table></figure><h4 id="Hash使用场景"><a href="#Hash使用场景" class="headerlink" title="Hash使用场景"></a>Hash使用场景</h4><ul><li>比如：用户信息、商品信息、文章信息、购物车信息等</li><li>应用场景：最新文章、最新动态等（还可以做简陋版的消息队列）</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set :"></a>Set :</h3><p>Set 类型是一种无序但都唯一的集合，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p><h4 id="Set常用命令"><a href="#Set常用命令" class="headerlink" title="Set常用命令"></a>Set常用命令</h4><ul><li>增加命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD key member1 [member2]  向集合添加一个或多个成员</span><br><span class="line">SUNIONSTORE destination key1 [key2]  所有给定集合的并集存储在 destination 集合中</span><br><span class="line">SMOVE source destination member  将 member 元素从 source 集合移动到 destination 集合</span><br></pre></td></tr></table></figure><ul><li>删除命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SREM key member1 [member2]移除集合中一个或多个成员</span><br><span class="line">SPOP key移除并返回集合中的一个随机元素</span><br></pre></td></tr></table></figure><ul><li>查找命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SCARD key获取集合的成员数</span><br><span class="line">SDIFF key1 [key2]返回第一个集合与其他集合之间的差异。</span><br><span class="line">SDIFFSTORE destination key1 [key2]返回给定所有集合的差集并存储在 destination 中</span><br><span class="line">SINTER key1 [key2]返回给定所有集合的交集</span><br><span class="line">SINTERSTORE destination key1 [key2]返回给定所有集合的交集并存储在 destination 中</span><br><span class="line">SMEMBERS key返回集合中的所有成员</span><br><span class="line">SRANDMEMBER key [count]返回集合中一个或多个随机数</span><br><span class="line">SUNION key1 [key2]返回所有给定集合的并集</span><br></pre></td></tr></table></figure><ul><li>修改命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member将 member 元素从 source 集合移动到 destination 集合</span><br><span class="line">SUNIONSTORE destination key1 [key2]所有给定集合的并集存储在 destination 集合中</span><br></pre></td></tr></table></figure><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>实现交集、并集、差集的操作，比如：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景</p><ul><li>应用场景：需要存放的数据不能重复的场景，文章点赞、动态点赞等场景</li></ul><h3 id="SortSet"><a href="#SortSet" class="headerlink" title="SortSet :"></a>SortSet :</h3><p> Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。</p><ul><li>应用场景：需要随机获取数据源中的元素根据某个权重进行排序的场景，比如排行榜等</li><li>应用场景：需要存储的数据有优先级或者重要程度的场景 比如优先级任务队列。</li></ul><h2 id="Redis的持久化机制"><a href="#Redis的持久化机制" class="headerlink" title="Redis的持久化机制"></a>Redis的持久化机制</h2><p>​        Redis将数据保存在内存中，一旦Redis服务器被关闭，或者运行Redis服务的主机本身被关闭的话，储存在内存里面的数据就会丢失。如果仅仅将Redis用作缓存的话，那么这种数据丢失带来的问题并不是非常大，只需要重启机器，然后再次将数据同步到缓存中就可以了。但如果将Redis用作DB的话，那么因为一些原因导致数据丢失的情况就不能接受。</p><p>​        Redis的持久化就是将储存在内存里面的数据以文件形式保存硬盘里面，这样即使Redis服务端被关闭，已经同步到硬盘里面的数据也不会丢失，除此之外，持久化也可以使Redis服务器重启时，通过载入同步的持久文件来还原之前的数据，或者使用持久化文件来进行数据备份和数据迁移等工作。</p><ul><li><strong>RDB持久化（默认采用的持久化方式）：</strong>RDB持久化功能可以将Redis中所有数据生成快照并以二进制文件的形式保存到硬盘里， 生成快照之后，可以将快照复制到其他服务器从⽽创建具有相同数据的服务器副本还可以将快照留在原地以便重启服务器的时候使⽤。</li><li><strong>AOF持久化：</strong>每执⾏⼀条会更改 Redis 中的数据的命令，Redis 就会将该命令写⼊硬盘中的 AOF ⽂件</li></ul><h1 id="高阶使用"><a href="#高阶使用" class="headerlink" title="高阶使用"></a>高阶使用</h1><h2 id="Redis的发布-订阅"><a href="#Redis的发布-订阅" class="headerlink" title="Redis的发布/订阅"></a>Redis的发布/订阅</h2><p>发布/订阅是一种消息模式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者），而是通过消息通道广播出去，让订阅该消息主题的订阅者消费到。</p><p>Redis提供了发布订阅功能，可以用于消息的传输，Redis的发布订阅机制包括三个部分：发布者（Publisher），订阅者（Subscriber）和频道（Channel）。发布/订阅者模式最大的特点就是实现了松耦合。</p><p>Redis发布订阅分为两种类型：基于频道的发布订阅、基于模式模式的发布订阅</p><h3 id="基于频道的发布订阅实现原理"><a href="#基于频道的发布订阅实现原理" class="headerlink" title="基于频道的发布订阅实现原理"></a>基于频道的发布订阅实现原理</h3><p>Redis将所有频道的订阅关系都保存在服务器状态的 pubsub_channels 字典中，Key值保存的是被订阅的频道名，Value值是一个链表，链表中保存着所有订阅这个频道的客户端ID。如图所示：</p><p><img src="/2022/05/13/Redis/Users/Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230218141653817.png" alt="image-20230218141653817"></p><p>当客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，这个客户端与被订阅频道之间就建立一种订阅关系</p><p><strong>建立订阅关系执行分两种情况：</strong></p><ul><li>该频道已有其他订阅者</li></ul><p>该频道在 pubsub_channels 字典中存在订阅者链表，将此客户端添加至订阅者链表末尾即可；</p><ul><li>该频道暂无订阅者</li></ul><p>该频道在 pubsub_channels 字典中不存在订阅者链表，首先在字典中为频道创建一个键，并将这个键的值设置为空链表，然后将客户端添加到链表，成为链表的第一个元素。</p><p>当客户端退订某个或某些频道的时候，服务器将从 pubsub_channels 中解除客户端与被退订频道之间的关联。</p><p><strong>解除订阅关系执行过程：</strong></p><ul><li><p>根据被退订频道的名字，在 pubsub_channels 字典中找到频道对应的订阅者链表，然后从订阅者链表中删除退订客户端的信息；</p></li><li><p>假如删除退订客户端后，频道的订阅者链表变成了空链表，那么说明这个频道已无任何订阅者了，将从 pubsub_channels 字典中删除频道对应的键。</p></li></ul><blockquote><p>注意如果字典中没有对应的频道，退订命令是没有用的</p></blockquote><h3 id="基于模式的发布订阅实现原理"><a href="#基于模式的发布订阅实现原理" class="headerlink" title="基于模式的发布订阅实现原理"></a>基于模式的发布订阅实现原理</h3><blockquote><p>模式与频道的区别，简单理解模式是多个频道的组合。</p></blockquote><p>Redis将所有模式的订阅关系都保存在服务器状态的 pubsub_patterns 链表，链表的每个节点都包含着一个 pubsub Pattern 结构，这个结构的 pattern 属性记录了被订阅的模式，而 client 属性则记录了订阅模式的客户端。如图所示：</p><p><img src="/2022/05/13/Redis/Users/Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230218143059762.png" alt="image-20230218143059762"></p><blockquote><ul><li>客户端 client-7 正在订阅模式 “book.*”</li><li>客户端 client-8 正在订阅模式 “column.*”</li></ul></blockquote><p>当客户端执行 PSUBSCRIBE 命令订阅某个或某些模式的时候，服务器会对每个被订阅的模式执行以下两个操作：</p><ul><li><p>新建一个  pubsubPattern结果，将结构的 pattern 属性设置为被订阅的模式，client 属性设置为订阅模式的客户端；</p></li><li><p>将pubsubPattern结构添加到 pubsub_patterns 链表的尾部</p></li></ul><p>​        当客户端退订某个或某些模式的时候，服务器将从 pubsub_patterns 链表中查找并删除那些 pattern 属性为被退订模式，并且client 属性为执行退订命令的客户端的 pubsubPattern 结构。</p><p>简单理解即：查找client、pattern 均相同的 pubsubPattern 并删除。</p><p><strong>发消息执行过程：</strong></p><ul><li><p>在 pubsub_channels 字典里找到频道 channel 的订阅者列表，然后将消息发送给列表上所有客户端；</p></li><li><p>遍历 pubsub_patterns 链表，查找与channel 频道相匹配的 pattern 模式，并将消息发送给订阅了这些 pattern 模式的客户端。</p></li></ul><blockquote><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1、订阅的消费者需要一直执行，阻塞获取消息，如果断开则表示退订了。</p><p>2、channel 只接收 publish 发送的消息，自身是不存储消息，假如 channel 没有被订阅，则消息会被丢弃</p><p>3、生产者生成消息时，只需要向频道内丢入消息即可</p></blockquote><p><strong>相关命令：</strong></p><ul><li><strong>subscribe channel [channel …]</strong> 订阅一个或多个频道</li><li><strong>unsubscribe channe1</strong> 退订指定频道</li><li><strong>publish channe1 message</strong> 对指定频道发送消息</li><li><strong>psubscribe pattern</strong> 订阅指定模式</li><li><strong>punsubscribe pattern</strong> 退订指定模式</li></ul><h3 id="发布订阅的优缺点"><a href="#发布订阅的优缺点" class="headerlink" title="发布订阅的优缺点"></a>发布订阅的优缺点</h3><p>PubSub 生产的消息，如果没有对应的频道或者消费者，消息会被丢弃，直接投递失败返回0状态。假如我们实际生产环境在消费的时候，突然网络波动，导致其中一个消费者挂掉了一段时间，那么当它重新连接上的时候，中间这一段时间产生的消息也将不会存在。也就是说 Redis 本身是不会存储消息体信息的。</p><p>那么在我们生产环境数量不大且想节约成本的时候，Redis 的发布订阅功能可能比较适合；轻量级、方便使用配合consul+supervisor+swool可以常驻内存，开多进程消费(消息队列也可以用的)。</p><h3 id="Redis发布订阅的应用场景"><a href="#Redis发布订阅的应用场景" class="headerlink" title="Redis发布订阅的应用场景"></a>Redis发布订阅的应用场景</h3><h4 id="Redis-Sentinel-节点发现"><a href="#Redis-Sentinel-节点发现" class="headerlink" title="Redis Sentinel 节点发现"></a>Redis Sentinel 节点发现</h4><p><strong>Redis Sentinel</strong> 是 Redis 一套高可用方案，可以在主节点故障的时候，自动将从节点提升为主节点，从而转移故障。<strong>Redis Sentinel</strong> 节点主要使用发布订阅机制，实现新节点的发现，以及交换主节点的之间的状态。</p><p>如下所示，在服务端，每一个 <strong>Sentinel</strong> 节点将会定时向 <code>_sentinel_:hello</code> 频道发送消息，并且每个 <strong>Sentinel</strong> 都会订阅这个节点。</p><p><img src="/2022/05/13/Redis/Users/Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230218152454421.png" alt="image-20230218152454421"></p><p>​        这样一旦有节点往这个频道发送消息，其他节点就可以立刻收到消息。这样一旦有的新节点加入，它往这个频道发送消息，其他节点收到之后，判断本地列表并没有这个节点，于是就可以当做新的节点加入本地节点列表。</p><p>除此之外，每次往这个频道发送消息内容可以包含节点的状态信息，这样可以作为后面 <strong>Sentinel</strong> 领导者选举的依据。    </p><h4 id="或者应用于"><a href="#或者应用于" class="headerlink" title="或者应用于"></a>或者应用于</h4><ul><li><strong>电商中，用户下单成功之后向指定频道发送消息，下游业务订阅支付结果这个频道处理自己相关业务逻辑</strong></li><li><strong>粉丝关注功能、文章推送等等…</strong></li></ul><h2 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h2><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>总结说：Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><h3 id="Redis事务的相关命令"><a href="#Redis事务的相关命令" class="headerlink" title="Redis事务的相关命令"></a>Redis事务的相关命令</h3><p>MULTI ：开启事务，Redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</p><p>EXEC：执行事务中的所有操作命令。</p><p>DISCARD：取消事务，放弃执行事务块中的所有命令。</p><p>WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</p><p>UNWATCH：取消WATCH对所有key的监视。</p><h3 id="Redis事务出现错误的处理"><a href="#Redis事务出现错误的处理" class="headerlink" title="Redis事务出现错误的处理"></a>Redis事务出现错误的处理</h3><p><strong>语法错误：（编译器错误）</strong></p><p>开启事务后提交两个修改命令，如果修改的语法出错（比如使用不存在的命令），会导致事务失败，两个修改都不生效</p><p><strong>Redis类型错误（运行时错误）</strong></p><p>开启事务后提交两个修改命令，在运行时检测到类型错误，会导致事务失败，但此时事务不会回滚，而是会跳过执行失败的命令继续执行。</p><h3 id="Redis事务执行步骤"><a href="#Redis事务执行步骤" class="headerlink" title="Redis事务执行步骤"></a>Redis事务执行步骤</h3><ul><li><strong>开启</strong>：以MULTI开始一个事务</li><li><strong>入队</strong>：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面</li><li><strong>执行</strong>：由EXEC命令触发事务</li></ul><p>当一个客户端切换到事务状态之后， 服务器会根据这个客户端发来的不同命令执行不同的操作：</p><ul><li>如果客户端发送的命令为 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令的其中一个， 那么服务器立即执行这个命令。</li><li>与此相反， 如果客户端发送的命令是 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令以外的其他命令， 那么服务器并不立即执行这个命令， 而是将这个命令放入一个事务队列里面， 然后向客户端返回 QUEUED 回复。</li></ul><h3 id="为什么Redis事务失败不支持回滚"><a href="#为什么Redis事务失败不支持回滚" class="headerlink" title="为什么Redis事务失败不支持回滚"></a>为什么Redis事务失败不支持回滚</h3><p>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面，这也就是说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</p><p>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</p><h3 id="如何理解Redis与事务的ACID"><a href="#如何理解Redis与事务的ACID" class="headerlink" title="如何理解Redis与事务的ACID"></a>如何理解Redis与事务的ACID</h3><p>一般来说，事务有四个性质称为ACID，分别是原子性，一致性，隔离性和持久性。这是基础，但是很多文章对Redis 是否支持ACID有一些异议，</p><ul><li><strong>原子性atomicity</strong></li></ul><p>首先通过上文知道 运行期的错误是不会回滚的，很多文章由此说Redis事务违背原子性的；而官方文档认为是遵从原子性的。</p><p>Redis官方文档给的理解是，<strong>Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行</strong>。而不是完全成功。</p><ul><li><strong>一致性consistency</strong></li></ul><p>Redis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非Redis进程意外终结。</p><ul><li><strong>隔离性Isolation</strong></li></ul><p>Redis事务是严格遵守隔离性的，原因是Redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。</p><p>但是，Redis不像其它结构化数据库有隔离级别这种设计。</p><ul><li><strong>持久性Durability</strong></li></ul><p><strong>Redis事务是不保证持久性的</strong>，这是因为Redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。</p><h3 id="Redis事务其它实现"><a href="#Redis事务其它实现" class="headerlink" title="Redis事务其它实现"></a>Redis事务其它实现</h3><p>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</p><h2 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h2><h2 id="Redission分布式锁"><a href="#Redission分布式锁" class="headerlink" title="Redission分布式锁"></a>Redission分布式锁</h2><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="底层数据结构详解"><a href="#底层数据结构详解" class="headerlink" title="底层数据结构详解"></a>底层数据结构详解</h2><p>跳表的原理</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础使用&quot;&gt;&lt;a href=&quot;#基础使用&quot; class=&quot;headerlink&quot; title=&quot;基础使用&quot;&gt;&lt;/a&gt;基础使用&lt;/h1&gt;&lt;h2 id=&quot;什么是Redis？为什么使用Redis？&quot;&gt;&lt;a href=&quot;#什么是Redis？为什么使用Redis？&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>开发经历</title>
    <link href="http://example.com/2022/03/15/%E5%BC%80%E5%8F%91%E7%BB%8F%E5%8E%86/"/>
    <id>http://example.com/2022/03/15/%E5%BC%80%E5%8F%91%E7%BB%8F%E5%8E%86/</id>
    <published>2022-03-15T14:19:47.000Z</published>
    <updated>2023-02-21T15:45:24.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、request请求的使用"><a href="#1、request请求的使用" class="headerlink" title="1、request请求的使用"></a>1、request请求的使用</h1><p>当时在想需要获取请求头之类的信息，需要用到request.getHeader()等方法，那是不是都要在Controller层传入这个参数，然后发现我们的Controller层继承一个自己封装的BaseController，BaseController里面实例化了这个变量，所以可以直接使用，不用在方法体中传参了。</p><h1 id="2、日志管理的实现"><a href="#2、日志管理的实现" class="headerlink" title="2、日志管理的实现"></a>2、日志管理的实现</h1><p>当时借鉴ruoyi框架的日志管理，用AOP的思想在登录验证中开启一个异步任务管理器，异步任务管理器开启一个线程来执行插入日志表的操作。就是不管是登录成功还是登录失败，都开启一个新线程用于执行插入日志的操作，来实现登录日志的写入。但是因为有SpringSercurity框架，导致新开的线程没法通过权限认证，登录直接报错没有权限。推测错误是SpringSercurity框架下多线程操作导致线程上下文的丢失，只要把主线程的信息注入到新线程就好了。</p><h1 id="3、时间范围处理："><a href="#3、时间范围处理：" class="headerlink" title="3、时间范围处理："></a>3、时间范围处理：</h1><p>前端只传到年月日这个精度，但是插入数据库的时间字段要精确到时分秒。处理方式：</p><p><img src="/imgs/image-20230216113637661.png" alt="image-20230216113637661"></p><h1 id="4、小功能"><a href="#4、小功能" class="headerlink" title="4、小功能"></a>4、小功能</h1><p>1.新增功能如果在页面中有下拉框的选择，需要先做一个查询的接口，再做新增的接口，前端怎么调用这两个接口就看前端的了</p><p>2.在mapper层定义一个查询接口查询你想要的数据，在mapper.xml文件中使用<assocation>标签就可以自动调用mapper层的接口方法获取到接口的返回值。用于通用查询映射结果。</assocation></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、request请求的使用&quot;&gt;&lt;a href=&quot;#1、request请求的使用&quot; class=&quot;headerlink&quot; title=&quot;1、request请求的使用&quot;&gt;&lt;/a&gt;1、request请求的使用&lt;/h1&gt;&lt;p&gt;当时在想需要获取请求头之类的信息，需要用到r</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基础</title>
    <link href="http://example.com/2022/02/15/%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/02/15/%E5%9F%BA%E7%A1%80/</id>
    <published>2022-02-15T06:06:31.000Z</published>
    <updated>2023-02-20T06:03:35.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><blockquote><p>Java基础部分，包括语法基础，泛型，注解，异常，反射和其它（如SPI机制等）。</p></blockquote><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h4 id="面向对象特性？"><a href="#面向对象特性？" class="headerlink" title="面向对象特性？"></a>面向对象特性？</h4><ul><li><strong>封装</strong></li></ul><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p>优点:</p><ul><li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p><p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender == <span class="number">0</span> ? <span class="string">&quot;man&quot;</span> : <span class="string">&quot;woman&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; is working very hard!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; can&#x27;t work any more!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>继承</strong></li></ul><p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure><ul><li><strong>多态</strong></li></ul><p>多态分为编译时多态和运行时多态:</p><ul><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><p>下面的代码中，乐器类(Instrument)有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Instrument is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wind</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wind is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Percussion</span> <span class="keyword">extends</span> <span class="title class_">Instrument</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Percussion is playing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Music</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Instrument&gt; instruments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        instruments.add(<span class="keyword">new</span> <span class="title class_">Wind</span>());</span><br><span class="line">        instruments.add(<span class="keyword">new</span> <span class="title class_">Percussion</span>());</span><br><span class="line">        <span class="keyword">for</span>(Instrument instrument : instruments) &#123;</span><br><span class="line">            instrument.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="a-a-b-与-a-b-的区别"><a href="#a-a-b-与-a-b-的区别" class="headerlink" title="a = a + b 与 a += b 的区别"></a>a = a + b 与 a += b 的区别</h4><p>+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">b = a + b; <span class="comment">// error : cannot convert from int to byte</span></span><br><span class="line">b += a; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>(因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错)</p><h4 id="3-0-1-0-3-将会返回什么-true-还是-false"><a href="#3-0-1-0-3-将会返回什么-true-还是-false" class="headerlink" title="3*0.1 == 0.3 将会返回什么? true 还是 false?"></a>3*0.1 == 0.3 将会返回什么? true 还是 false?</h4><p>false，因为有些浮点数不能完全精确的表示出来。</p><h4 id="能在-Switch-中使用-String-吗"><a href="#能在-Switch-中使用-String-吗" class="headerlink" title="能在 Switch 中使用 String 吗?"></a>能在 Switch 中使用 String 吗?</h4><p>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</p><h4 id="对equals-和hashCode-的理解"><a href="#对equals-和hashCode-的理解" class="headerlink" title="对equals()和hashCode()的理解?"></a>对equals()和hashCode()的理解?</h4><ul><li><strong>为什么在重写 equals 方法的时候需要重写 hashCode 方法</strong>?</li></ul><p>因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p><ul><li><strong>有没有可能两个不相等的对象有相同的 hashcode</strong>?</li></ul><p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</p><ul><li><strong>两个相同的对象会有不同的 hash code 吗</strong>?</li></ul><p>不能，根据 hash code 的规定，这是不可能的。</p><h4 id="final、finalize-和-finally-的不同之处"><a href="#final、finalize-和-finally-的不同之处" class="headerlink" title="final、finalize 和 finally 的不同之处?"></a>final、finalize 和 finally 的不同之处?</h4><ul><li>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。</li><li>Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。</li><li>finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</li></ul><h4 id="String、StringBuffer与StringBuilder的区别？"><a href="#String、StringBuffer与StringBuilder的区别？" class="headerlink" title="String、StringBuffer与StringBuilder的区别？"></a>String、StringBuffer与StringBuilder的区别？</h4><p>第一点: 可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。</p><p>第二点: 线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。</p><h4 id="接口与抽象类的区别？"><a href="#接口与抽象类的区别？" class="headerlink" title="接口与抽象类的区别？"></a>接口与抽象类的区别？</h4><ul><li>一个子类只能继承一个抽象类, 但能实现多个接口</li><li>抽象类可以有构造方法, 接口没有构造方法</li><li>抽象类可以有普通成员变量, 接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li><li>抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法</li><li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li><li>抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法</li></ul><h4 id="this-amp-super-在构造方法中的区别？"><a href="#this-amp-super-在构造方法中的区别？" class="headerlink" title="this() &amp; super()在构造方法中的区别？"></a>this() &amp; super()在构造方法中的区别？</h4><ul><li>调用super()必须写在子类构造方法的第一行, 否则编译不通过</li><li>super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行</li><li>尽管可以用this调用一个构造器, 却不能调用2个</li><li>this和super不能出现在同一个构造器中, 否则编译不通过</li><li>this()、super()都指的对象,不可以在static环境中使用</li><li>本质this指向本对象的指针。super是一个关键字</li></ul><h4 id="Java移位运算符？"><a href="#Java移位运算符？" class="headerlink" title="Java移位运算符？"></a>Java移位运算符？</h4><p>Java中有三种移位运算符</p><ul><li><code>&lt;&lt;</code> :左移运算符,<code>x &lt;&lt; 1</code>,相当于x乘以2(不溢出的情况下),低位补0</li><li><code>&gt;&gt;</code> :带符号右移,<code>x &gt;&gt; 1</code>,相当于x除以2,正数高位补0,负数高位补1</li><li><code>&gt;&gt;&gt;</code> :无符号右移,忽略符号位,空位都以0补齐</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h4 id="为什么需要泛型？"><a href="#为什么需要泛型？" class="headerlink" title="为什么需要泛型？"></a>为什么需要泛型？</h4><ol><li><strong>适用于多种数据类型执行相同的代码</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">add</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>泛型中的类型在使用时指定，不需要强制类型转换</strong>（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li></ul><p>看下这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;xxString&quot;</span>);</span><br><span class="line">list.add(<span class="number">100d</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br></pre></td></tr></table></figure><p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现<code>java.lang.ClassCastException</code>异常。</p><p>引入泛型，它将提供类型的约束，提供编译前的检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// list中只能放String, 不能放其它类型的元素</span></span><br></pre></td></tr></table></figure><h4 id="泛型类如何定义使用？"><a href="#泛型类如何定义使用？" class="headerlink" title="泛型类如何定义使用？"></a>泛型类如何定义使用？</h4><ul><li>从一个简单的泛型类看起：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&lt;T&gt;&#123;         <span class="comment">// 此处可以随便写标识符号，T是type的简称  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// var的类型由T指定，即：由外部指定  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  <span class="comment">// 返回值的类型由外部决定  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  <span class="comment">// 设置的类型也由外部决定  </span></span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo06</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Point&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Point</span>&lt;String&gt;() ;     <span class="comment">// 里面的var类型为String类型  </span></span><br><span class="line">        p.setVar(<span class="string">&quot;it&quot;</span>) ;                            <span class="comment">// 设置字符串  </span></span><br><span class="line">        System.out.println(p.getVar().length()) ;   <span class="comment">// 取得字符串的长度  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多元泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="comment">// 此处指定了两个泛型类型  </span></span><br><span class="line">    <span class="keyword">private</span> K key ;     <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">private</span> V value ;   <span class="comment">// 此变量的类型由外部决定  </span></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(K key)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.key = key ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(V value)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo09</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Notepad&lt;String,Integer&gt; t = <span class="literal">null</span> ;        <span class="comment">// 定义两个泛型类型的对象  </span></span><br><span class="line">        t = <span class="keyword">new</span> <span class="title class_">Notepad</span>&lt;String,Integer&gt;() ;       <span class="comment">// 里面的key为String，value为Integer  </span></span><br><span class="line">        t.setKey(<span class="string">&quot;汤姆&quot;</span>) ;        <span class="comment">// 设置第一个内容  </span></span><br><span class="line">        t.setValue(<span class="number">20</span>) ;            <span class="comment">// 设置第二个内容  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;姓名；&quot;</span> + t.getKey()) ;      <span class="comment">// 取得信息  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;，年龄；&quot;</span> + t.getValue()) ;       <span class="comment">// 取得信息  </span></span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口如何定义使用？"><a href="#泛型接口如何定义使用？" class="headerlink" title="泛型接口如何定义使用？"></a>泛型接口如何定义使用？</h4><ul><li>简单的泛型接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&lt;T&gt;&#123;        <span class="comment">// 在接口上定义泛型  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span> ; <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InfoImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Info</span>&lt;T&gt;&#123;   <span class="comment">// 定义泛型接口的子类  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;             <span class="comment">// 定义属性  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;     <span class="comment">// 通过构造方法设置属性内容  </span></span><br><span class="line">        <span class="built_in">this</span>.setVar(<span class="keyword">var</span>) ;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo24</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String arsg[])</span>&#123;  </span><br><span class="line">        Info&lt;String&gt; i = <span class="literal">null</span>;        <span class="comment">// 声明接口对象  </span></span><br><span class="line">        i = <span class="keyword">new</span> <span class="title class_">InfoImpl</span>&lt;String&gt;(<span class="string">&quot;汤姆&quot;</span>) ;  <span class="comment">// 通过子类实例化对象  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span> + i.getVar()) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="泛型方法如何定义使用？"><a href="#泛型方法如何定义使用？" class="headerlink" title="泛型方法如何定义使用？"></a>泛型方法如何定义使用？</h4><p>泛型方法，是在调用方法的时候指明泛型的具体类型。</p><ul><li>定义泛型方法语法格式</li></ul><p><img src="/images/java/java-basic-generic-4.png" alt="img"></p><ul><li>调用泛型方法语法格式</li></ul><p><img src="/images/java/java-basic-generic-5.png" alt="img"></p><p>说明一下，定义泛型方法时，必须在返回值前边加一个``，来声明这是一个泛型方法，持有一个泛型<code>T</code>，然后才可以用泛型T作为方法的返回值。</p><p><code>Class</code>的作用就是指明泛型的具体类型，而<code>Class</code>类型的变量c，可以用来创建泛型类的对象。</p><p>为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。</p><p>泛型方法要求的参数是<code>Class</code>类型，而<code>Class.forName()</code>方法的返回值也是<code>Class</code>，因此可以用<code>Class.forName()</code>作为参数。其中，<code>forName()</code>方法中的参数是何种类型，返回的<code>Class</code>就是何种类型。在本例中，<code>forName()</code>方法中传入的是User类的完整路径，因此返回的是<code>Class</code>类型的对象，因此调用泛型方法时，变量c的类型就是<code>Class</code>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。</p><p>当然，泛型方法不是仅仅可以有一个参数<code>Class</code>，可以根据需要添加其他参数。</p><p><strong>为什么要使用泛型方法呢</strong>？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p><h4 id="泛型的上限和下限？"><a href="#泛型的上限和下限？" class="headerlink" title="泛型的上限和下限？"></a>泛型的上限和下限？</h4><p>在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><p>上限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;&#123;    <span class="comment">// 此处泛型只能是数字类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        Info&lt;Integer&gt; i1 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;Integer&gt;() ;        <span class="comment">// 声明Integer的泛型对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo21</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        Info&lt;String&gt; i1 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;String&gt;() ;        <span class="comment">// 声明String的泛型对象</span></span><br><span class="line">        Info&lt;Object&gt; i2 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;Object&gt;() ;        <span class="comment">// 声明Object的泛型对象</span></span><br><span class="line">        i1.setVar(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        i2.setVar(<span class="keyword">new</span> <span class="title class_">Object</span>()) ;</span><br><span class="line">        fun(i1) ;</span><br><span class="line">        fun(i2) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(Info&lt;? <span class="built_in">super</span> String&gt; temp)</span>&#123;    <span class="comment">// 只能接收String或Object类型的泛型，String类的父类只有Object类</span></span><br><span class="line">        System.out.print(temp + <span class="string">&quot;, &quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-异常"><a href="#1-4-异常" class="headerlink" title="1.4 异常"></a>1.4 异常</h3><h4 id="Java异常类层次结构"><a href="#Java异常类层次结构" class="headerlink" title="Java异常类层次结构?"></a>Java异常类层次结构?</h4><ul><li><p>Throwable</p><p>是 Java 语言中所有错误与异常的超类。 </p><ul><li><strong>Error</strong> 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</li><li><strong>Exception</strong> 程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</li></ul></li></ul><p><img src="/images/java/java-basic-exception-1.png" alt="img"></p><ul><li><strong>运行时异常</strong></li></ul><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><ul><li><strong>非运行时异常</strong> （编译异常）</li></ul><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h4 id="可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）区别？"><a href="#可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）区别？" class="headerlink" title="可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）区别？"></a>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）区别？</h4><ul><li><strong>可查异常</strong>（编译器要求必须处置的异常）：</li></ul><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><ul><li><strong>不可查异常</strong>(编译器不要求强制处置的异常)</li></ul><p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p><h4 id="throw和throws的区别？"><a href="#throw和throws的区别？" class="headerlink" title="throw和throws的区别？"></a>throw和throws的区别？</h4><ul><li><strong>异常的申明(throws)</strong></li></ul><p>在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException, FileNotFoundException&#123;</span><br><span class="line">    <span class="comment">//something statements</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>异常的抛出(throw)</strong></li></ul><p>如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;参数不能为0&quot;</span>); <span class="comment">//抛出一个运行时异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5.0</span> / value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p><p><img src="/images/java/java-basic-reflection-3.png" alt="img"></p><h4 id="反射的使用？"><a href="#反射的使用？" class="headerlink" title="反射的使用？"></a>反射的使用？</h4><p>在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)</p><ul><li>Class类对象的获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取Class对象的三种方式</span></span><br><span class="line">    logger.info(<span class="string">&quot;根据类名:  \t&quot;</span> + User.class);</span><br><span class="line">    logger.info(<span class="string">&quot;根据对象:  \t&quot;</span> + <span class="keyword">new</span> <span class="title class_">User</span>().getClass());</span><br><span class="line">    logger.info(<span class="string">&quot;根据全限定类名:\t&quot;</span> + Class.forName(<span class="string">&quot;com.test.User&quot;</span>));</span><br><span class="line">    <span class="comment">// 常用的方法</span></span><br><span class="line">    logger.info(<span class="string">&quot;获取全限定类名:\t&quot;</span> + userClass.getName());</span><br><span class="line">    logger.info(<span class="string">&quot;获取类名:\t&quot;</span> + userClass.getSimpleName());</span><br><span class="line">    logger.info(<span class="string">&quot;实例化:\t&quot;</span> + userClass.newInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Constructor类及其用法</li><li>Field类及其用法</li><li>Method类及其用法</li></ul><h4 id><a href="#" class="headerlink" title></a></h4><h1 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h1><blockquote><p>集合容器主要包括 单列集合Collection 和双列集合 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。</p></blockquote><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="集合有哪些类？"><a href="#集合有哪些类？" class="headerlink" title="集合有哪些类？"></a>集合有哪些类？</h4><ul><li>Set <ul><li>TreeSet 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li><li>HashSet 基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li><li>LinkedHashSet 具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li></ul></li><li>List <ul><li>ArrayList 基于动态数组实现，支持随机访问。</li><li>Vector 和 ArrayList 类似，但它是线程安全的。</li><li>LinkedList 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul></li><li>Queue <ul><li>LinkedList 可以用它来实现双向队列。</li><li>PriorityQueue 基于堆结构实现，可以用它来实现优先队列。</li></ul></li></ul><h4 id="ArrayList的底层？"><a href="#ArrayList的底层？" class="headerlink" title="ArrayList的底层？"></a>ArrayList的底层？</h4><p><em>ArrayList</em>实现了<em>List</em>接口，是有序的，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。每个<em>ArrayList</em>都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。（即扩容）</p><p><img src="/images/collection/ArrayList_base.png" alt="ArrayList_base"></p><h4 id="ArrayList自动扩容？"><a href="#ArrayList自动扩容？" class="headerlink" title="ArrayList自动扩容？"></a>ArrayList自动扩容？</h4><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过ensureCapacity(int minCapacity)方法来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p><p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p><p><img src="/images/collection/ArrayList_add.png" alt="ArrayList_add"></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="Map有哪些类？"><a href="#Map有哪些类？" class="headerlink" title="Map有哪些类？"></a>Map有哪些类？</h4><ul><li><code>TreeMap</code> 基于红黑树实现。</li><li><code>HashMap</code> 1.7基于哈希表实现，1.8基于数组+链表+红黑树。</li><li><code>HashTable</code> 和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且保证数据的一致。它是遗留类，不推荐使用。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高(1.7 ConcurrentHashMap 引入了分段锁, 1.8 引入了红黑树)。</li><li><code>LinkedHashMap</code> 使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</li></ul><h4 id="JDK7-HashMap如何实现？"><a href="#JDK7-HashMap如何实现？" class="headerlink" title="JDK7 HashMap如何实现？"></a>JDK7 HashMap如何实现？</h4><p>哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。<strong>Java7 *HashMap*采用的是冲突链表方式</strong>。</p><p><img src="/images/collection/HashMap_base.png" alt="HashMap_base"></p><p>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p><p>有两个参数可以影响<em>HashMap</em>的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><h4 id="JDK8-HashMap如何实现？"><a href="#JDK8-HashMap如何实现？" class="headerlink" title="JDK8 HashMap如何实现？"></a>JDK8 HashMap如何实现？</h4><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p><img src="/images/java/java-collection-hashmap8.png" alt="img"></p><h4 id="HashSet是如何实现的？"><a href="#HashSet是如何实现的？" class="headerlink" title="HashSet是如何实现的？"></a>HashSet是如何实现的？</h4><p><em>HashSet</em>是对<em>HashMap</em>的简单包装，对<em>HashSet</em>的函数调用都会转换成合适的<em>HashMap</em>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是WeakHashMap"><a href="#什么是WeakHashMap" class="headerlink" title="什么是WeakHashMap?"></a>什么是WeakHashMap?</h4><p>我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，<strong>是否有有效的引用指向该对象</strong>。如果没有有效引用指向该对象(基本意味着不存在访问该对象的方式)，那么该对象就是可回收的。这里的<strong>有效引用</strong> 并不包括<strong>弱引用</strong>。也就是说，<strong>虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收</strong>。</p><p>WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？</p><p><em>WeakHashMap</em> 里的<code>entry</code>可能会被GC自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。</p><p>*<strong>WeakHashMap* 的这个特点特别适用于需要缓存的场景</strong>。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。</p><h1 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h1><blockquote><p>多线程的出现是要解决什么问题的?</p><p>线程不安全是指什么? </p><p>并发出现线程不安全的本质什么? 可见性，原子性和有序性。</p><p>Java是怎么解决并发问题的? 3个关键字、JMM和8个Happens-Before</p><p>线程安全是不是非真即假? 不是</p><p>线程安全有哪些实现思路?</p></blockquote><h2 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h2><h3 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h3><p>​        进程是程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>​        线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程，与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>总结：</strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h3><p>多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p><h3 id="多线程的出现是要解决什么问题的-本质什么"><a href="#多线程的出现是要解决什么问题的-本质什么" class="headerlink" title="多线程的出现是要解决什么问题的? 本质什么?"></a>多线程的出现是要解决什么问题的? 本质什么?</h3><p>CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；<strong>导致了可见性问题</strong></li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异； <strong>导致了原子性问题</strong></li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。<strong>导致了有序性问题</strong></li></ul><h3 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h3><p>并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p><h3 id="Java是怎么解决并发问题的"><a href="#Java是怎么解决并发问题的" class="headerlink" title="Java是怎么解决并发问题的?"></a>Java是怎么解决并发问题的?</h3><p><strong>理解的第一个维度：核心知识点</strong></p><p>JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p><ul><li>volatile、synchronized 和 final 三个关键字</li><li>Happens-Before 规则</li></ul><p><strong>理解的第二个维度：可见性，有序性，原子性</strong></p><ul><li><strong>原子性</strong></li></ul><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 请分析以下哪些操作是原子性操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;        <span class="comment">//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span></span><br><span class="line">y = x;         <span class="comment">//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span></span><br><span class="line">x++;           <span class="comment">//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4： 同语句3</span></span><br></pre></td></tr></table></figure><p>上面4个语句只有语句1的操作具备原子性。</p><p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p><blockquote><p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性，但会造成性能的消耗。</p></blockquote><ul><li><strong>可见性</strong></li></ul><p>Java提供了volatile关键字来保证可见性。</p><p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><blockquote><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p></blockquote><ul><li><strong>有序性</strong></li></ul><p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。</p><h4 id="保证线程安全有哪些实现思路"><a href="#保证线程安全有哪些实现思路" class="headerlink" title="保证线程安全有哪些实现思路?"></a>保证线程安全有哪些实现思路?</h4><ol><li><strong>互斥同步</strong></li></ol><p>synchronized 和 ReentrantLock。</p><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁。</p><ol start="2"><li> <strong>非阻塞同步</strong></li></ol><ul><li>CAS</li></ul><p>​         使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><pre><code>     乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</code></pre><ul><li>AtomicInteger</li></ul><p>​         JUC 包里面的整数原子类 AtomicInteger，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。</p><ol start="3"><li><strong>无同步方案</strong></li></ol><p>​        要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><ul><li>栈封闭</li></ul><p>​       多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p><ul><li>线程本地存储(Thread Local Storage)</li></ul><p>​        如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><h3 id="什么是线程死锁-如何预防和避免死锁"><a href="#什么是线程死锁-如何预防和避免死锁" class="headerlink" title="什么是线程死锁?如何预防和避免死锁?"></a>什么是线程死锁?如何预防和避免死锁?</h3><p>​        举个例子：线程 A 持有资源 1，线程 B 持有资源 2，他们同时都想申请对方的资源，但是又不释放手中的资源，所以这两个线程就会互相等待而进入死锁状态。</p><ul><li><p><strong>死锁产生的四个必要条件：</strong></p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol></li><li><p><strong>如何预防死锁的产生？破坏死锁产生的必要条件即可</strong></p><ul><li>破坏请求与保持b条件 ：一次性申请所有的资源。</li><li>破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件、</li></ul></li></ul><h3 id="线程有哪几种状态"><a href="#线程有哪几种状态" class="headerlink" title="线程有哪几种状态?"></a>线程有哪几种状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</p></li><li><p>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p></li><li><p>BLOCKED ：阻塞状态，需要等待锁释放。</p></li><li><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p></li><li><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p></li><li><p>TERMINATED：终止状态，表示该线程已经运行完毕。</p><p><img src="/2022/02/15/%E5%9F%BA%E7%A1%80/Users/Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230217124539152.png" alt="image-20230217124539152"></p></li></ul><h4 id="通常线程有哪几种使用方式"><a href="#通常线程有哪几种使用方式" class="headerlink" title="通常线程有哪几种使用方式?"></a>通常线程有哪几种使用方式?</h4><p>有三种使用线程的方法:</p><ul><li><p>实现 Runnable 接口；</p><p>需要实现接口中的 run() 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">      MyRunnable instance = new MyRunnable();</span><br><span class="line">      Thread thread = new Thread(instance);</span><br><span class="line">      thread.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 Callable 接口；</p><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    public Integer call() &#123;</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    MyCallable mc = new MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = new Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承 Thread 类。</p><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyThread mt = new MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p></li></ul><h4 id="基础线程机制有哪些"><a href="#基础线程机制有哪些" class="headerlink" title="基础线程机制有哪些?"></a>基础线程机制有哪些?</h4><ul><li><strong>Executor</strong></li></ul><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p><p>主要有三种 Executor:</p><ol><li>CachedThreadPool: 一个任务创建一个线程；</li><li>FixedThreadPool: 所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。</li></ol><ul><li><strong>Daemon</strong></li></ul><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。使用 setDaemon() 方法将一个线程设置为守护线程。</p><ul><li><strong>sleep()</strong></li></ul><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p><ul><li><strong>yield()</strong></li></ul><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><h4 id="线程的中断方式有哪些"><a href="#线程的中断方式有哪些" class="headerlink" title="线程的中断方式有哪些?"></a>线程的中断方式有哪些?</h4><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><ul><li><strong>InterruptedException</strong></li></ul><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$<span class="number">0</span>(InterruptExample.java:<span class="number">5</span>)</span><br><span class="line">    at InterruptExample$$Lambda$<span class="number">1</span>/<span class="number">713338599.</span>run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>interrupted()</strong></li></ul><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><ul><li><strong>Executor 的中断操作</strong></li></ul><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><h4 id="线程之间有哪些协作方式"><a href="#线程之间有哪些协作方式" class="headerlink" title="线程之间有哪些协作方式?"></a>线程之间有哪些协作方式?</h4><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p><ul><li><strong>join()</strong></li></ul><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">JoinExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinExample</span>();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><ul><li><strong>wait()、 notify()、 notifyAll()</strong></li></ul><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><p>它们都属于 Object 的一部分，而不属于 Thread。</p><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><p><strong>wait() 和 sleep() 的区别</strong></p><ul><li><p>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</p></li><li><p>wait() 会释放锁，sleep() 不会。</p></li><li><p><strong>await() signal() signalAll()</strong></p></li></ul><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p><h2 id="并发关键字"><a href="#并发关键字" class="headerlink" title="并发关键字"></a>并发关键字</h2><ul><li><a href>关键字: synchronized详解</a></li><li><a href>关键字: volatile详解</a></li><li><a href>关键字: final详解</a></li></ul><h2 id="JUC全局观"><a href="#JUC全局观" class="headerlink" title="JUC全局观"></a>JUC全局观</h2><h4 id="JUC框架包含几个部分"><a href="#JUC框架包含几个部分" class="headerlink" title="JUC框架包含几个部分?"></a>JUC框架包含几个部分?</h4><p>五个部分：</p><ul><li>Lock框架和Tools类(把这两个放到一起理解)</li><li>Collections: 并发集合</li><li>Atomic: 原子类</li><li>Executors: 线程池</li></ul><h4 id="线程安全的实现方法有哪些"><a href="#线程安全的实现方法有哪些" class="headerlink" title="线程安全的实现方法有哪些?"></a>线程安全的实现方法有哪些?</h4><p>线程安全的实现方法包含:</p><ul><li>互斥同步: synchronized 和 ReentrantLock</li><li>非阻塞同步: CAS, AtomicXXXX</li><li>无同步方案: 栈封闭，Thread Local，可重入代码</li></ul><h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS?"></a>什么是CAS?</h4><p>CAS的全称为Compare-And-Swap，直译就是对比交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。   简单解释：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</p><p>CAS操作是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁。JDK中大量使用了CAS来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新。</p><h4 id="CAS使用示例，结合AtomicInteger给出示例"><a href="#CAS使用示例，结合AtomicInteger给出示例" class="headerlink" title="CAS使用示例，结合AtomicInteger给出示例?"></a>CAS使用示例，结合AtomicInteger给出示例?</h4><p>如果不使用CAS，在高并发下，多线程同时修改一个变量的值我们需要synchronized加锁(可能有人说可以用Lock加锁，Lock底层的AQS也是基于CAS进行获取锁的)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中为我们提供了AtomicInteger 原子类(底层基于CAS进行更新数据的)，不需要加锁就在多线程并发场景下实现数据的一致性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i.addAndGet(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CAS会有哪些问题"><a href="#CAS会有哪些问题" class="headerlink" title="CAS会有哪些问题?"></a>CAS会有哪些问题?</h4><p>CAS 方式为乐观锁，synchronized 为悲观锁。因此使用 CAS 解决并发问题通常情况下性能更优。</p><p>但使用 CAS 方式也会有几个问题：</p><ul><li><strong>ABA问题</strong></li></ul><p>因为CAS需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A。</p><p>从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><ul><li><strong>循环时间长开销大</strong></li></ul><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><ul><li><strong>只能保证一个共享变量的原子操作</strong></li></ul><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p><p>还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i = 2，j = a，合并一下ij = 2a，然后用CAS来操作ij。</p><p>从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p><h4 id="通过wait-notify实现同步"><a href="#通过wait-notify实现同步" class="headerlink" title="通过wait/notify实现同步?"></a>通过wait/notify实现同步?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before notify&quot;</span>);            </span><br><span class="line">            notify();</span><br><span class="line">            System.out.println(<span class="string">&quot;after notify&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitAndNotifyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();            </span><br><span class="line">        <span class="keyword">synchronized</span> (myThread) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;        </span><br><span class="line">                myThread.start();</span><br><span class="line">                <span class="comment">// 主线程睡眠3s</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;before wait&quot;</span>);</span><br><span class="line">                <span class="comment">// 阻塞主线程</span></span><br><span class="line">                myThread.wait();</span><br><span class="line">                System.out.println(<span class="string">&quot;after wait&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before wait</span><br><span class="line">before notify</span><br><span class="line">after notify</span><br><span class="line">after wait</span><br></pre></td></tr></table></figure><p>说明: 具体的流程图如下</p><p><img src="/images/thread/java-thread-x-locksupport-1.png" alt="img"></p><p>使用wait/notify实现同步时，必须先调用wait，后调用notify，如果先调用notify，再调用wait，将起不了作用。具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before notify&quot;</span>);            </span><br><span class="line">            notify();</span><br><span class="line">            System.out.println(<span class="string">&quot;after notify&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitAndNotifyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();        </span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="comment">// 主线程睡眠3s</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (myThread) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;        </span><br><span class="line">                System.out.println(<span class="string">&quot;before wait&quot;</span>);</span><br><span class="line">                <span class="comment">// 阻塞主线程</span></span><br><span class="line">                myThread.wait();</span><br><span class="line">                System.out.println(<span class="string">&quot;after wait&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before notify</span><br><span class="line">after notify</span><br><span class="line">before wait</span><br></pre></td></tr></table></figure><p>说明: 由于先调用了notify，再调用的wait，此时主线程还是会一直阻塞。</p><h4 id="通过LockSupport的park-unpark实现同步？"><a href="#通过LockSupport的park-unpark实现同步？" class="headerlink" title="通过LockSupport的park/unpark实现同步？"></a>通过LockSupport的park/unpark实现同步？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before unpark&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取blocker</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Blocker info &quot;</span> + LockSupport.getBlocker((Thread) object));</span><br><span class="line">        <span class="comment">// 释放许可</span></span><br><span class="line">        LockSupport.unpark((Thread) object);</span><br><span class="line">        <span class="comment">// 休眠500ms，保证先执行park中的setBlocker(t, null);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再次获取blocker</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Blocker info &quot;</span> + LockSupport.getBlocker((Thread) object));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;after unpark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(Thread.currentThread());</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;before park&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        LockSupport.park(<span class="string">&quot;ParkAndUnparkDemo&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;after park&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before park</span><br><span class="line">before unpark</span><br><span class="line">Blocker info ParkAndUnparkDemo</span><br><span class="line">after park</span><br><span class="line">Blocker info null</span><br><span class="line">after unpark</span><br></pre></td></tr></table></figure><p>说明: 本程序先执行park，然后在执行unpark，进行同步，并且在unpark的前后都调用了getBlocker，可以看到两次的结果不一样，并且第二次调用的结果为null，这是因为在调用unpark之后，执行了Lock.park(Object blocker)函数中的setBlocker(t, null)函数，所以第二次调用getBlocker时为null。</p><p>上例是先调用park，然后调用unpark，现在修改程序，先调用unpark，然后调用park，看能不能正确同步。具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before unpark&quot;</span>);        </span><br><span class="line">        <span class="comment">// 释放许可</span></span><br><span class="line">        LockSupport.unpark((Thread) object);</span><br><span class="line">        System.out.println(<span class="string">&quot;after unpark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParkAndUnparkDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(Thread.currentThread());</span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 主线程睡眠3s</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;before park&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        LockSupport.park(<span class="string">&quot;ParkAndUnparkDemo&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;after park&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before unpark</span><br><span class="line">after unpark</span><br><span class="line">before park</span><br><span class="line">after park</span><br></pre></td></tr></table></figure><p>说明: 可以看到，在先调用unpark，再调用park时，仍能够正确实现同步，不会造成由wait/notify调用顺序不当所引起的阻塞。因此park/unpark相比wait/notify更加的灵活。</p><h4 id="Thread-sleep-、Object-wait-、Condition-await-、LockSupport-park-的区别-重点"><a href="#Thread-sleep-、Object-wait-、Condition-await-、LockSupport-park-的区别-重点" class="headerlink" title="# Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点"></a><a href="#thread-sleep-%E3%80%81object-wait-%E3%80%81condition-await-%E3%80%81locksupport-park-%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%87%8D%E7%82%B9">#</a> Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点</h4><ul><li><strong>Thread.sleep()和Object.wait()的区别</strong></li></ul><p>首先，我们先来看看Thread.sleep()和Object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点。</p><ol><li>Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；</li><li>Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；</li><li>Thread.sleep()到时间了会自动唤醒，然后继续执行；</li><li>Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；</li><li>Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；</li></ol><p>其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。</p><ul><li><strong>Object.wait()和Condition.await()的区别</strong></li></ul><p>Object.wait()和Condition.await()的原理是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。</p><p>实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。</p><ul><li><strong>Thread.sleep()和LockSupport.park()的区别</strong> LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。</li></ul><ol><li>从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；</li><li>Thread.sleep()没法从外部唤醒，只能自己醒过来；</li><li>LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</li><li>Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；</li><li>LockSupport.park()方法不需要捕获中断异常；</li><li>Thread.sleep()本身就是一个native方法；</li><li>LockSupport.park()底层是调用的Unsafe的native方法；</li></ol><ul><li><strong>Object.wait()和LockSupport.park()的区别</strong></li></ul><p>二者都会阻塞当前线程的运行，他们有什么区别呢? 经过上面的分析相信你一定很清楚了，真的吗? 往下看！</p><ol><li>Object.wait()方法需要在synchronized块中执行；</li><li>LockSupport.park()可以在任意地方执行；</li><li>Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；</li><li>LockSupport.park()不需要捕获中断异常；</li><li>Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；</li><li>LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；</li></ol><p>park()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。</p><h4 id="如果在wait-之前执行了notify-会怎样"><a href="#如果在wait-之前执行了notify-会怎样" class="headerlink" title="# 如果在wait()之前执行了notify()会怎样?"></a><a href="#%E5%A6%82%E6%9E%9C%E5%9C%A8wait-%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E4%BA%86notify-%E4%BC%9A%E6%80%8E%E6%A0%B7">#</a> 如果在wait()之前执行了notify()会怎样?</h4><p>如果当前的线程不是此对象锁的所有者，却调用该对象的notify()或wait()方法时抛出IllegalMonitorStateException异常；</p><p>如果当前线程是此对象锁的所有者，wait()将一直阻塞，因为后续将没有其它notify()唤醒它。</p><h4 id="如果在park-之前执行了unpark-会怎样"><a href="#如果在park-之前执行了unpark-会怎样" class="headerlink" title="# 如果在park()之前执行了unpark()会怎样?"></a><a href="#%E5%A6%82%E6%9E%9C%E5%9C%A8park-%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E4%BA%86unpark-%E4%BC%9A%E6%80%8E%E6%A0%B7">#</a> 如果在park()之前执行了unpark()会怎样?</h4><p>线程不会被阻塞，直接跳过park()，继续执行后续内容</p><h4 id="什么是AQS-为什么它是核心"><a href="#什么是AQS-为什么它是核心" class="headerlink" title="什么是AQS? 为什么它是核心?"></a>什么是AQS? 为什么它是核心?</h4><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</p><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>AbstractQueuedSynchronizer类底层的数据结构是使用<strong>CLH(Craig,Landin,and Hagersten)队列</strong>是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。其中Sync queue，即同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度。而Condition queue不是必须的，其是一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition queue。</p><p><img src="/images/thread/java-thread-x-juc-aqs-1.png" alt="image"></p><h4 id="AQS的核心思想是什么"><a href="#AQS的核心思想是什么" class="headerlink" title="# AQS的核心思想是什么?"></a><a href="#aqs%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E6%98%AF%E4%BB%80%E4%B9%88">#</a> AQS的核心思想是什么?</h4><p>底层数据结构: AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><h4 id="AQS有哪些核心的方法"><a href="#AQS有哪些核心的方法" class="headerlink" title="# AQS有哪些核心的方法?"></a><a href="#aqs%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E7%9A%84%E6%96%B9%E6%B3%95">#</a> AQS有哪些核心的方法?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="type">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure><h4 id="AQS定义什么样的资源获取方式"><a href="#AQS定义什么样的资源获取方式" class="headerlink" title="AQS定义什么样的资源获取方式?"></a>AQS定义什么样的资源获取方式?</h4><p>AQS定义了两种资源获取方式：</p><ul><li><strong>独占</strong>(只有一个线程能访问执行，又根据是否按队列的顺序分为<strong>公平锁</strong>和<strong>非公平锁</strong>，如<code>ReentrantLock</code>)</li><li><strong>共享</strong>(多个线程可同时访问执行，如<code>Semaphore</code>、<code>CountDownLatch</code>、 <code>CyclicBarrier</code> )。<code>ReentrantReadWriteLock</code>可以看成是组合式，允许多个线程同时对某一资源进行读。</li></ul><h4 id="AQS底层使用了什么样的设计模式"><a href="#AQS底层使用了什么样的设计模式" class="headerlink" title="AQS底层使用了什么样的设计模式?"></a>AQS底层使用了什么样的设计模式?</h4><p>模板， 共享锁和独占锁在一个接口类中。</p><ul><li><a href>JUC锁: ReentrantLock详解</a></li></ul><h4 id="什么是可重入，什么是可重入锁-它用来解决什么问题"><a href="#什么是可重入，什么是可重入锁-它用来解决什么问题" class="headerlink" title="什么是可重入，什么是可重入锁? 它用来解决什么问题?"></a>什么是可重入，什么是可重入锁? 它用来解决什么问题?</h4><p><strong>可重入</strong>：（来源于维基百科）若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。</p><p><strong>可重入锁</strong>：又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p><h4 id="ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗"><a href="#ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗" class="headerlink" title="ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗?"></a>ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗?</h4><p>ReentrantLock总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。</p><p><img src="/images/thread/java-thread-x-juc-reentrantlock-1.png" alt="image"></p><p>说明: ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。下面逐个进行分析。</p><h4 id="ReentrantLock是如何实现公平锁的"><a href="#ReentrantLock是如何实现公平锁的" class="headerlink" title="ReentrantLock是如何实现公平锁的?"></a>ReentrantLock是如何实现公平锁的?</h4><p>FairSync</p><h4 id="ReentrantLock是如何实现非公平锁的"><a href="#ReentrantLock是如何实现非公平锁的" class="headerlink" title="ReentrantLock是如何实现非公平锁的?"></a>ReentrantLock是如何实现非公平锁的?</h4><p>UnFairSync</p><h4 id="ReentrantLock默认实现的是公平还是非公平锁"><a href="#ReentrantLock默认实现的是公平还是非公平锁" class="headerlink" title="ReentrantLock默认实现的是公平还是非公平锁?"></a>ReentrantLock默认实现的是公平还是非公平锁?</h4><p>非公平锁</p><h4 id="为了有了ReentrantLock还需要ReentrantReadWriteLock"><a href="#为了有了ReentrantLock还需要ReentrantReadWriteLock" class="headerlink" title="为了有了ReentrantLock还需要ReentrantReadWriteLock?"></a>为了有了ReentrantLock还需要ReentrantReadWriteLock?</h4><p>读锁和写锁分离：ReentrantReadWriteLock表示可重入读写锁，ReentrantReadWriteLock中包含了两种锁，读锁ReadLock和写锁WriteLock，可以通过这两种锁实现线程间的同步。</p><h4 id="ReentrantReadWriteLock底层实现原理"><a href="#ReentrantReadWriteLock底层实现原理" class="headerlink" title="ReentrantReadWriteLock底层实现原理?"></a>ReentrantReadWriteLock底层实现原理?</h4><p>ReentrantReadWriteLock有五个内部类，五个内部类之间也是相互关联的。内部类的关系如下图所示。</p><p><img src="/images/thread/java-thread-x-readwritelock-1.png" alt="img"></p><p>说明: 如上图所示，Sync继承自AQS、NonfairSync继承自Sync类、FairSync继承自Sync类；ReadLock实现了Lock接口、WriteLock也实现了Lock接口。</p><h4 id="ReentrantReadWriteLock底层读写状态如何设计的"><a href="#ReentrantReadWriteLock底层读写状态如何设计的" class="headerlink" title="ReentrantReadWriteLock底层读写状态如何设计的?"></a>ReentrantReadWriteLock底层读写状态如何设计的?</h4><p>高16位为读锁，低16位为写锁</p><h4 id="读锁和写锁的最大数量是多少"><a href="#读锁和写锁的最大数量是多少" class="headerlink" title="# 读锁和写锁的最大数量是多少?"></a><a href="#%E8%AF%BB%E9%94%81%E5%92%8C%E5%86%99%E9%94%81%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F%E6%98%AF%E5%A4%9A%E5%B0%91">#</a> 读锁和写锁的最大数量是多少?</h4><p>2的16次方-1</p><h4 id="本地线程计数器ThreadLocalHoldCounter是用来做什么的"><a href="#本地线程计数器ThreadLocalHoldCounter是用来做什么的" class="headerlink" title="# 本地线程计数器ThreadLocalHoldCounter是用来做什么的?"></a><a href="#%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B%E8%AE%A1%E6%95%B0%E5%99%A8threadlocalholdcounter%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84">#</a> 本地线程计数器ThreadLocalHoldCounter是用来做什么的?</h4><p>本地线程计数器，与对象绑定（线程-》线程重入的次数）</p><h4 id="写锁的获取与释放是怎么实现的"><a href="#写锁的获取与释放是怎么实现的" class="headerlink" title="# 写锁的获取与释放是怎么实现的?"></a><a href="#%E5%86%99%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E9%87%8A%E6%94%BE%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">#</a> 写锁的获取与释放是怎么实现的?</h4><p>tryAcquire/tryRelease</p><h4 id="读锁的获取与释放是怎么实现的"><a href="#读锁的获取与释放是怎么实现的" class="headerlink" title="# 读锁的获取与释放是怎么实现的?"></a><a href="#%E8%AF%BB%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E9%87%8A%E6%94%BE%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">#</a> 读锁的获取与释放是怎么实现的?</h4><p>tryAcquireShared/tryReleaseShared</p><h4 id="什么是锁的升降级"><a href="#什么是锁的升降级" class="headerlink" title="# 什么是锁的升降级?"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%9A%84%E5%8D%87%E9%99%8D%E7%BA%A7">#</a> 什么是锁的升降级?</h4><p>RentrantReadWriteLock为什么不支持锁升级? RentrantReadWriteLock不支持锁升级(把持读锁、获取写锁，最后释放读锁的过程)。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。</p><h3 id="3-6-JUC集合类"><a href="#3-6-JUC集合类" class="headerlink" title="# 3.6 JUC集合类"></a><a href="#_3-6-juc%E9%9B%86%E5%90%88%E7%B1%BB">#</a> 3.6 JUC集合类</h3><ul><li><a href>JUC集合: ConcurrentHashMap详解</a></li><li><a href>JUC集合: CopyOnWriteArrayList详解</a></li><li><a href>JUC集合: ConcurrentLinkedQueue详解</a></li><li><a href>JUC集合: BlockingQueue详解</a></li></ul><h4 id="为什么HashTable慢-它的并发度是什么-那么ConcurrentHashMap并发度是什么"><a href="#为什么HashTable慢-它的并发度是什么-那么ConcurrentHashMap并发度是什么" class="headerlink" title="# 为什么HashTable慢? 它的并发度是什么? 那么ConcurrentHashMap并发度是什么?"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88hashtable%E6%85%A2-%E5%AE%83%E7%9A%84%E5%B9%B6%E5%8F%91%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88-%E9%82%A3%E4%B9%88concurrenthashmap%E5%B9%B6%E5%8F%91%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88">#</a> 为什么HashTable慢? 它的并发度是什么? 那么ConcurrentHashMap并发度是什么?</h4><p>Hashtable之所以效率低下主要是因为其实现使用了synchronized关键字对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下。</p><h4 id="ConcurrentHashMap在JDK1-7和JDK1-8中实现有什么差别-JDK1-8解決了JDK1-7中什么问题"><a href="#ConcurrentHashMap在JDK1-7和JDK1-8中实现有什么差别-JDK1-8解決了JDK1-7中什么问题" class="headerlink" title="# ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别? JDK1.8解決了JDK1.7中什么问题"></a><a href="#concurrenthashmap%E5%9C%A8jdk1-7%E5%92%8Cjdk1-8%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%88%AB-jdk1-8%E8%A7%A3%E6%B1%BA%E4%BA%86jdk1-7%E4%B8%AD%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">#</a> ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别? JDK1.8解決了JDK1.7中什么问题</h4><ul><li><code>HashTable</code> : 使用了synchronized关键字对put等操作进行加锁;</li><li><code>ConcurrentHashMap JDK1.7</code>: 使用分段锁机制实现;</li><li><code>ConcurrentHashMap JDK1.8</code>: 则使用数组+链表+红黑树数据结构和CAS原子操作实现;</li></ul><h4 id="ConcurrentHashMap-JDK1-7实现的原理是什么"><a href="#ConcurrentHashMap-JDK1-7实现的原理是什么" class="headerlink" title="# ConcurrentHashMap JDK1.7实现的原理是什么?"></a><a href="#concurrenthashmap-jdk1-7%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">#</a> ConcurrentHashMap JDK1.7实现的原理是什么?</h4><p>在JDK1.5~1.7版本，Java使用了分段锁机制实现ConcurrentHashMap.</p><p>简而言之，ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，它通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。因此，ConcurrentHashMap在多线程并发编程中可是实现多线程put操作。</p><p><img src="/images/thread/java-thread-x-concurrent-hashmap-1.png" alt="img"></p><p><code>concurrencyLevel</code>: Segment 数（并行级别、并发数）。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><h4 id="ConcurrentHashMap-JDK1-7中Segment数-concurrencyLevel-默认值是多少-为何一旦初始化就不可再扩容"><a href="#ConcurrentHashMap-JDK1-7中Segment数-concurrencyLevel-默认值是多少-为何一旦初始化就不可再扩容" class="headerlink" title="# ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少? 为何一旦初始化就不可再扩容?"></a><a href="#concurrenthashmap-jdk1-7%E4%B8%ADsegment%E6%95%B0-concurrencylevel-%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91-%E4%B8%BA%E4%BD%95%E4%B8%80%E6%97%A6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B0%B1%E4%B8%8D%E5%8F%AF%E5%86%8D%E6%89%A9%E5%AE%B9">#</a> ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少? 为何一旦初始化就不可再扩容?</h4><p>默认是 16</p><h4 id="ConcurrentHashMap-JDK1-7说说其put的机制"><a href="#ConcurrentHashMap-JDK1-7说说其put的机制" class="headerlink" title="# ConcurrentHashMap JDK1.7说说其put的机制?"></a><a href="#concurrenthashmap-jdk1-7%E8%AF%B4%E8%AF%B4%E5%85%B6put%E7%9A%84%E6%9C%BA%E5%88%B6">#</a> ConcurrentHashMap JDK1.7说说其put的机制?</h4><p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂</p><ol><li>计算 key 的 hash 值</li><li>根据 hash 值找到 Segment 数组中的位置 j； ensureSegment(j) 对 segment[j] 进行初始化（Segment 内部是由 <strong>数组+链表</strong> 组成的）</li><li>插入新值到 槽 s 中</li></ol><h4 id="ConcurrentHashMap-JDK1-7是如何扩容的"><a href="#ConcurrentHashMap-JDK1-7是如何扩容的" class="headerlink" title="# ConcurrentHashMap JDK1.7是如何扩容的?"></a><a href="#concurrenthashmap-jdk1-7%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84">#</a> ConcurrentHashMap JDK1.7是如何扩容的?</h4><p>rehash(注：segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容)</p><h4 id="ConcurrentHashMap-JDK1-8实现的原理是什么"><a href="#ConcurrentHashMap-JDK1-8实现的原理是什么" class="headerlink" title="# ConcurrentHashMap JDK1.8实现的原理是什么?"></a><a href="#concurrenthashmap-jdk1-8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">#</a> ConcurrentHashMap JDK1.8实现的原理是什么?</h4><p>在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。</p><p>简而言之：数组+链表+红黑树，CAS</p><h4 id="ConcurrentHashMap-JDK1-8是如何扩容的"><a href="#ConcurrentHashMap-JDK1-8是如何扩容的" class="headerlink" title="# ConcurrentHashMap JDK1.8是如何扩容的?"></a><a href="#concurrenthashmap-jdk1-8%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84">#</a> ConcurrentHashMap JDK1.8是如何扩容的?</h4><p>tryPresize, 扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍</p><h4 id="ConcurrentHashMap-JDK1-8链表转红黑树的时机是什么-临界值为什么是8"><a href="#ConcurrentHashMap-JDK1-8链表转红黑树的时机是什么-临界值为什么是8" class="headerlink" title="# ConcurrentHashMap JDK1.8链表转红黑树的时机是什么? 临界值为什么是8?"></a><a href="#concurrenthashmap-jdk1-8%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%97%B6%E6%9C%BA%E6%98%AF%E4%BB%80%E4%B9%88-%E4%B8%B4%E7%95%8C%E5%80%BC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF8">#</a> ConcurrentHashMap JDK1.8链表转红黑树的时机是什么? 临界值为什么是8?</h4><p>size = 8, log(N)</p><h4 id="ConcurrentHashMap-JDK1-8是如何进行数据迁移的"><a href="#ConcurrentHashMap-JDK1-8是如何进行数据迁移的" class="headerlink" title="# ConcurrentHashMap JDK1.8是如何进行数据迁移的?"></a><a href="#concurrenthashmap-jdk1-8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E7%9A%84">#</a> ConcurrentHashMap JDK1.8是如何进行数据迁移的?</h4><p>transfer, 将原来的 tab 数组的元素迁移到新的 nextTab 数组中</p><h4 id="先说说非并发集合中Fail-fast机制"><a href="#先说说非并发集合中Fail-fast机制" class="headerlink" title="# 先说说非并发集合中Fail-fast机制?"></a><a href="#%E5%85%88%E8%AF%B4%E8%AF%B4%E9%9D%9E%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%ADfail-fast%E6%9C%BA%E5%88%B6">#</a> 先说说非并发集合中Fail-fast机制?</h4><p>快速失败</p><h4 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="# CopyOnWriteArrayList的实现原理?"></a><a href="#copyonwritearraylist%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">#</a> CopyOnWriteArrayList的实现原理?</h4><p>COW基于拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将toCopyIn转化为Object[]类型数组，然后设置当前数组</span></span><br><span class="line">setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br></pre></td></tr></table></figure><p>属性中有一个可重入锁，用来保证线程安全访问，还有一个Object类型的数组，用来存放具体的元素。当然，也使用到了反射机制和CAS来保证原子性的修改lock域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可重入锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 对象数组，用于存放元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="comment">// 反射机制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">// lock域的内存偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> lockOffset;</span><br></pre></td></tr></table></figure><h4 id="弱一致性的迭代器原理是怎么样的"><a href="#弱一致性的迭代器原理是怎么样的" class="headerlink" title="# 弱一致性的迭代器原理是怎么样的?"></a><a href="#%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">#</a> 弱一致性的迭代器原理是怎么样的?</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COWIterator</span><br></pre></td></tr></table></figure><p>COWIterator表示迭代器，其也有一个Object类型的数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作(remove、set 和 add)不受支持。这些方法将抛出 UnsupportedOperationException。</p><h4 id="CopyOnWriteArrayList为什么并发安全且性能比Vector好"><a href="#CopyOnWriteArrayList为什么并发安全且性能比Vector好" class="headerlink" title="# CopyOnWriteArrayList为什么并发安全且性能比Vector好?"></a><a href="#copyonwritearraylist%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E4%B8%94%E6%80%A7%E8%83%BD%E6%AF%94vector%E5%A5%BD">#</a> CopyOnWriteArrayList为什么并发安全且性能比Vector好?</h4><p>Vector对单独的add，remove等方法都是在方法上加了synchronized; 并且如果一个线程A调用size时，另一个线程B 执行了remove，然后size的值就不是最新的，然后线程A调用remove就会越界(这时就需要再加一个Synchronized)。这样就导致有了双重锁，效率大大降低，何必呢。于是vector废弃了，要用就用CopyOnWriteArrayList 吧。</p><h4 id="CopyOnWriteArrayList有何缺陷，说说其应用场景"><a href="#CopyOnWriteArrayList有何缺陷，说说其应用场景" class="headerlink" title="# CopyOnWriteArrayList有何缺陷，说说其应用场景?"></a><a href="#copyonwritearraylist%E6%9C%89%E4%BD%95%E7%BC%BA%E9%99%B7-%E8%AF%B4%E8%AF%B4%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">#</a> CopyOnWriteArrayList有何缺陷，说说其应用场景?</h4><p>CopyOnWriteArrayList 有几个缺点：</p><ul><li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc</li><li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；</li></ul><p><strong>CopyOnWriteArrayList 合适读多写少的场景，不过这类慎用</strong></p><p>因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</p><h4 id="要想用线程安全的队列有哪些选择"><a href="#要想用线程安全的队列有哪些选择" class="headerlink" title="# 要想用线程安全的队列有哪些选择?"></a><a href="#%E8%A6%81%E6%83%B3%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%89%E6%8B%A9">#</a> 要想用线程安全的队列有哪些选择?</h4><p>Vector，<code>Collections.synchronizedList( List list)</code>, ConcurrentLinkedQueue等</p><h4 id="ConcurrentLinkedQueue实现的数据结构"><a href="#ConcurrentLinkedQueue实现的数据结构" class="headerlink" title="# ConcurrentLinkedQueue实现的数据结构?"></a><a href="#concurrentlinkedqueue%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">#</a> ConcurrentLinkedQueue实现的数据结构?</h4><p>ConcurrentLinkedQueue的数据结构与LinkedBlockingQueue的数据结构相同，都是使用的链表结构。ConcurrentLinkedQueue的数据结构如下:</p><p><img src="/images/thread/java-thread-x-juc-concurrentlinkedqueue-1.png" alt="img"></p><p>说明: ConcurrentLinkedQueue采用的链表结构，并且包含有一个头节点和一个尾结点。</p><h4 id="ConcurrentLinkedQueue底层原理"><a href="#ConcurrentLinkedQueue底层原理" class="headerlink" title="# ConcurrentLinkedQueue底层原理?"></a><a href="#concurrentlinkedqueue%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">#</a> ConcurrentLinkedQueue底层原理?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射机制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">// head域的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> headOffset;</span><br><span class="line"><span class="comment">// tail域的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> tailOffset;</span><br></pre></td></tr></table></figure><p>说明: 属性中包含了head域和tail域，表示链表的头节点和尾结点，同时，ConcurrentLinkedQueue也使用了反射机制和CAS机制来更新头节点和尾结点，保证原子性。</p><h4 id="ConcurrentLinkedQueue的核心方法有哪些"><a href="#ConcurrentLinkedQueue的核心方法有哪些" class="headerlink" title="# ConcurrentLinkedQueue的核心方法有哪些?"></a><a href="#concurrentlinkedqueue%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> ConcurrentLinkedQueue的核心方法有哪些?</h4><p>offer()，poll()，peek()，isEmpty()等队列常用方法</p><h4 id="说说ConcurrentLinkedQueue的HOPS-延迟更新的策略-的设计"><a href="#说说ConcurrentLinkedQueue的HOPS-延迟更新的策略-的设计" class="headerlink" title="# 说说ConcurrentLinkedQueue的HOPS(延迟更新的策略)的设计?"></a><a href="#%E8%AF%B4%E8%AF%B4concurrentlinkedqueue%E7%9A%84hops-%E5%BB%B6%E8%BF%9F%E6%9B%B4%E6%96%B0%E7%9A%84%E7%AD%96%E7%95%A5-%E7%9A%84%E8%AE%BE%E8%AE%A1">#</a> 说说ConcurrentLinkedQueue的HOPS(延迟更新的策略)的设计?</h4><p>通过上面对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为：</p><ul><li><strong>tail更新触发时机</strong>：当tail指向的节点的下一个节点不为null的时候，会执行定位队列真正的队尾节点的操作，找到队尾节点后完成插入之后才会通过casTail进行tail更新；当tail指向的节点的下一个节点为null的时候，只插入节点不更新tail。</li><li><strong>head更新触发时机</strong>：当head指向的节点的item域为null的时候，会执行定位队列真正的队头节点的操作，找到队头节点后完成删除之后才会通过updateHead进行head更新；当head指向的节点的item域不为null的时候，只删除节点不更新head。</li></ul><p>并且在更新操作时，源码中会有注释为：<code>hop two nodes at a time</code>。所以这种延迟更新的策略就被叫做HOPS的大概原因是这个(猜的 😃)，从上面更新时的状态图可以看出，head和tail的更新是“跳着的”即中间总是间隔了一个。那么这样设计的意图是什么呢?</p><p>如果让tail永远作为队列的队尾节点，实现的代码量会更少，而且逻辑更易懂。但是，这样做有一个缺点，如果大量的入队操作，每次都要执行CAS进行tail的更新，汇总起来对性能也会是大大的损耗。如果能减少CAS更新的操作，无疑可以大大提升入队的操作效率，所以doug lea大师每间隔1次(tail和队尾节点的距离为1)进行才利用CAS更新tail。对head的更新也是同样的道理，虽然，这样设计会多出在循环中定位队尾节点，但总体来说读的操作效率要远远高于写的性能，因此，多出来的在循环中定位尾节点的操作的性能损耗相对而言是很小的。</p><h4 id="ConcurrentLinkedQueue适合什么样的使用场景"><a href="#ConcurrentLinkedQueue适合什么样的使用场景" class="headerlink" title="# ConcurrentLinkedQueue适合什么样的使用场景?"></a><a href="#concurrentlinkedqueue%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">#</a> ConcurrentLinkedQueue适合什么样的使用场景?</h4><p>ConcurrentLinkedQueue通过无锁来做到了更高的并发量，是个高性能的队列，但是使用场景相对不如阻塞队列常见，毕竟取数据也要不停的去循环，不如阻塞的逻辑好设计，但是在并发量特别大的情况下，是个不错的选择，性能上好很多，而且这个队列的设计也是特别费力，尤其的使用的改良算法和对哨兵的处理。整体的思路都是比较严谨的，这个也是使用了无锁造成的，我们自己使用无锁的条件的话，这个队列是个不错的参考。</p><h4 id="什么是BlockingDeque-适合用在什么样的场景"><a href="#什么是BlockingDeque-适合用在什么样的场景" class="headerlink" title="# 什么是BlockingDeque? 适合用在什么样的场景?"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AFblockingdeque-%E9%80%82%E5%90%88%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%9C%BA%E6%99%AF">#</a> 什么是BlockingDeque? 适合用在什么样的场景?</h4><p>BlockingQueue 通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述:</p><p><img src="/images/thread/java-thread-x-blocking-queue-1.png" alt="img"></p><p>一个线程往里边放，另外一个线程从里边取的一个 BlockingQueue。</p><p>一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。 负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。</p><h4 id="BlockingQueue大家族有哪些"><a href="#BlockingQueue大家族有哪些" class="headerlink" title="# BlockingQueue大家族有哪些?"></a><a href="#blockingqueue%E5%A4%A7%E5%AE%B6%E6%97%8F%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> BlockingQueue大家族有哪些?</h4><p>ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue, SynchronousQueue…</p><h4 id="BlockingQueue常用的方法"><a href="#BlockingQueue常用的方法" class="headerlink" title="# BlockingQueue常用的方法?"></a><a href="#blockingqueue%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95">#</a> BlockingQueue常用的方法?</h4><p>BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下:</p><table><thead><tr><th></th><th>抛异常</th><th>特定值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(o)</td><td>offer(o)</td><td>put(o)</td><td>offer(o, timeout, timeunit)</td></tr><tr><td>移除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(timeout, timeunit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td></td><td></td></tr></tbody></table><p>四组不同的行为方式解释:</p><ul><li>抛异常: 如果试图的操作无法立即执行，抛一个异常。</li><li>特定值: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li><li>阻塞: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li><li>超时: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</li></ul><h4 id="BlockingQueue-实现例子"><a href="#BlockingQueue-实现例子" class="headerlink" title="# BlockingQueue 实现例子?"></a><a href="#blockingqueue-%E5%AE%9E%E7%8E%B0%E4%BE%8B%E5%AD%90">#</a> BlockingQueue 实现例子?</h4><p>这里是一个 Java 中使用 BlockingQueue 的示例。本示例使用的是 BlockingQueue 接口的 ArrayBlockingQueue 实现。 首先，BlockingQueueExample 类分别在两个独立的线程中启动了一个 Producer 和 一个 Consumer。Producer 向一个共享的 BlockingQueue 中注入字符串，而 Consumer 则会从中把它们拿出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueExample</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">1024</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是 Producer 类。注意它在每次 put() 调用时是如何休眠一秒钟的。这将导致 Consumer 在等待队列中对象的时候发生阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            queue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是 Consumer 类。它只是把对象从队列中抽取出来，然后将它们打印到 System.out。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是BlockingDeque-适合用在什么样的场景-1"><a href="#什么是BlockingDeque-适合用在什么样的场景-1" class="headerlink" title="# 什么是BlockingDeque? 适合用在什么样的场景?"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AFblockingdeque-%E9%80%82%E5%90%88%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%9C%BA%E6%99%AF-1">#</a> 什么是BlockingDeque? 适合用在什么样的场景?</h4><p>java.util.concurrent 包里的 BlockingDeque 接口表示一个线程安放入和提取实例的双端队列。</p><p>BlockingDeque 类是一个双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程。 deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。</p><p>在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 BlockingDeque。如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，这个时候也可以使用 BlockingDeque。BlockingDeque 图解:</p><p><img src="/images/thread/java-thread-x-blocking-deque-1.png" alt="img"></p><h4 id="BlockingDeque-与BlockingQueue有何关系，请对比下它们的方法"><a href="#BlockingDeque-与BlockingQueue有何关系，请对比下它们的方法" class="headerlink" title="# BlockingDeque 与BlockingQueue有何关系，请对比下它们的方法?"></a><a href="#blockingdeque-%E4%B8%8Eblockingqueue%E6%9C%89%E4%BD%95%E5%85%B3%E7%B3%BB-%E8%AF%B7%E5%AF%B9%E6%AF%94%E4%B8%8B%E5%AE%83%E4%BB%AC%E7%9A%84%E6%96%B9%E6%B3%95">#</a> BlockingDeque 与BlockingQueue有何关系，请对比下它们的方法?</h4><p>BlockingDeque 接口继承自 BlockingQueue 接口。这就意味着你可以像使用一个 BlockingQueue 那样使用 BlockingDeque。如果你这么干的话，各种插入方法将会把新元素添加到双端队列的尾端，而移除方法将会把双端队列的首端的元素移除。正如 BlockingQueue 接口的插入和移除方法一样。</p><p>以下是 BlockingDeque 对 BlockingQueue 接口的方法的具体内部实现:</p><table><thead><tr><th>BlockingQueue</th><th>BlockingDeque</th></tr></thead><tbody><tr><td>add()</td><td>addLast()</td></tr><tr><td>offer() x 2</td><td>offerLast() x 2</td></tr><tr><td>put()</td><td>putLast()</td></tr><tr><td>remove()</td><td>removeFirst()</td></tr><tr><td>poll() x 2</td><td>pollFirst()</td></tr><tr><td>take()</td><td>takeFirst()</td></tr><tr><td>element()</td><td>getFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><h4 id="BlockingDeque大家族有哪些"><a href="#BlockingDeque大家族有哪些" class="headerlink" title="# BlockingDeque大家族有哪些?"></a><a href="#blockingdeque%E5%A4%A7%E5%AE%B6%E6%97%8F%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> BlockingDeque大家族有哪些?</h4><p>LinkedBlockingDeque 是一个双端队列，在它为空的时候，一个试图从中抽取数据的线程将会阻塞，无论该线程是试图从哪一端抽取数据。</p><h4 id="BlockingDeque-实现例子"><a href="#BlockingDeque-实现例子" class="headerlink" title="# BlockingDeque 实现例子?"></a><a href="#blockingdeque-%E5%AE%9E%E7%8E%B0%E4%BE%8B%E5%AD%90">#</a> BlockingDeque 实现例子?</h4><p>既然 BlockingDeque 是一个接口，那么你想要使用它的话就得使用它的众多的实现类的其中一个。java.util.concurrent 包提供了以下 BlockingDeque 接口的实现类: LinkedBlockingDeque。</p><p>以下是如何使用 BlockingDeque 方法的一个简短代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlockingDeque&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;String&gt;();</span><br><span class="line">deque.addFirst(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">deque.addLast(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">String</span> <span class="variable">two</span> <span class="operator">=</span> deque.takeLast();</span><br><span class="line"><span class="type">String</span> <span class="variable">one</span> <span class="operator">=</span> deque.takeFirst();</span><br></pre></td></tr></table></figure><h3 id="3-7-JUC线程池"><a href="#3-7-JUC线程池" class="headerlink" title="# 3.7 JUC线程池"></a><a href="#_3-7-juc%E7%BA%BF%E7%A8%8B%E6%B1%A0">#</a> 3.7 JUC线程池</h3><ul><li><a href>JUC线程池: FutureTask详解</a></li><li><a href>JUC线程池: ThreadPoolExecutor详解</a></li><li><a href>JUC线程池: ScheduledThreadPool详解</a></li><li><a href>JUC线程池: Fork/Join框架详解</a></li></ul><h4 id="FutureTask用来解决什么问题的-为什么会出现"><a href="#FutureTask用来解决什么问题的-为什么会出现" class="headerlink" title="# FutureTask用来解决什么问题的? 为什么会出现?"></a><a href="#futuretask%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E7%9A%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0">#</a> FutureTask用来解决什么问题的? 为什么会出现?</h4><p>FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。FutureTask 的线程安全由CAS来保证。</p><h4 id="FutureTask类结构关系怎么样的"><a href="#FutureTask类结构关系怎么样的" class="headerlink" title="# FutureTask类结构关系怎么样的?"></a><a href="#futuretask%E7%B1%BB%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">#</a> FutureTask类结构关系怎么样的?</h4><p><img src="/images/thread/java-thread-x-juc-futuretask-1.png" alt="img"></p><p>可以看到,FutureTask实现了RunnableFuture接口，则RunnableFuture接口继承了Runnable接口和Future接口，所以FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。</p><h4 id="FutureTask的线程安全是由什么保证的"><a href="#FutureTask的线程安全是由什么保证的" class="headerlink" title="# FutureTask的线程安全是由什么保证的?"></a><a href="#futuretask%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%98%AF%E7%94%B1%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84">#</a> FutureTask的线程安全是由什么保证的?</h4><p>FutureTask 的线程安全由CAS来保证。</p><h4 id="FutureTask通常会怎么用-举例说明。"><a href="#FutureTask通常会怎么用-举例说明。" class="headerlink" title="# FutureTask通常会怎么用? 举例说明。"></a><a href="#futuretask%E9%80%9A%E5%B8%B8%E4%BC%9A%E6%80%8E%E4%B9%88%E7%94%A8-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E3%80%82">#</a> FutureTask通常会怎么用? 举例说明。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一种方式:Future + ExecutorService</span></span><br><span class="line"><span class="comment">         * Task task = new Task();</span></span><br><span class="line"><span class="comment">         * ExecutorService service = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">         * Future&lt;Integer&gt; future = service.submit(task1);</span></span><br><span class="line"><span class="comment">         * service.shutdown();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二种方式: FutureTask + ExecutorService</span></span><br><span class="line"><span class="comment">         * ExecutorService executor = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">         * Task task = new Task();</span></span><br><span class="line"><span class="comment">         * FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line"><span class="comment">         * executor.submit(futureTask);</span></span><br><span class="line"><span class="comment">         * executor.shutdown();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第三种方式:FutureTask + Thread</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2. 新建FutureTask,需要一个实现了Callable接口的类的实例作为构造函数参数</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        <span class="comment">// 3. 新建Thread对象并启动</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.setName(<span class="string">&quot;Task thread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;Thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] is running&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 4. 调用isDone()判断任务是否结束</span></span><br><span class="line">        <span class="keyword">if</span>(!futureTask.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task is not done&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5. 调用get()方法获取任务结果,如果任务没有执行完成则阻塞等待</span></span><br><span class="line">            result = futureTask.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;result is &quot;</span> + result);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1. 继承Callable接口,实现call()方法,泛型参数为要返回的类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span>  <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] is running&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>;++i) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么要有线程池"><a href="#为什么要有线程池" class="headerlink" title="# 为什么要有线程池?"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BA%BF%E7%A8%8B%E6%B1%A0">#</a> 为什么要有线程池?</h4><p>线程池能够对线程进行统一分配，调优和监控:</p><ul><li>降低资源消耗(线程无限制地创建，然后使用完毕后销毁)</li><li>提高响应速度(无须创建线程)</li><li>提高线程的可管理性</li></ul><h4 id="Java是实现和管理线程池有哪些方式-请简单举例如何使用。"><a href="#Java是实现和管理线程池有哪些方式-请简单举例如何使用。" class="headerlink" title="# Java是实现和管理线程池有哪些方式? 请简单举例如何使用。"></a><a href="#java%E6%98%AF%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F-%E8%AF%B7%E7%AE%80%E5%8D%95%E4%B8%BE%E4%BE%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E3%80%82">#</a> Java是实现和管理线程池有哪些方式? 请简单举例如何使用。</h4><p>从JDK 5开始，把工作单元与执行机制分离开来，工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</p><ul><li>WorkerThread</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkerThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WorkerThread</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.command=s;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Start. Command = &quot;</span>+command);</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; End.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SimpleThreadPool</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleThreadPool</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkerThread</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            executor.execute(worker);</span><br><span class="line">          &#125;</span><br><span class="line">        executor.shutdown(); <span class="comment">// This will make the executor accept no new threads and finish all existing threads in the queue</span></span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123; <span class="comment">// Wait until all threads are finish,and also you can use &quot;executor.awaitTermination();&quot; to wait</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中我们创建了固定大小为五个工作线程的线程池。然后分配给线程池十个工作，因为线程池大小为五，它将启动五个工作线程先处理五个工作，其他的工作则处于等待状态，一旦有工作完成，空闲下来工作线程就会捡取等待队列里的其他工作进行执行。</p><p>这里是以上程序的输出。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2 Start. Command = 1</span><br><span class="line">pool-1-thread-4 Start. Command = 3</span><br><span class="line">pool-1-thread-1 Start. Command = 0</span><br><span class="line">pool-1-thread-3 Start. Command = 2</span><br><span class="line">pool-1-thread-5 Start. Command = 4</span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">pool-1-thread-5 End.</span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">pool-1-thread-3 End.</span><br><span class="line">pool-1-thread-3 Start. Command = 8</span><br><span class="line">pool-1-thread-2 End.</span><br><span class="line">pool-1-thread-2 Start. Command = 9</span><br><span class="line">pool-1-thread-1 Start. Command = 7</span><br><span class="line">pool-1-thread-5 Start. Command = 6</span><br><span class="line">pool-1-thread-4 Start. Command = 5</span><br><span class="line">pool-1-thread-2 End.</span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">pool-1-thread-3 End.</span><br><span class="line">pool-1-thread-5 End.</span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><p>输出表明线程池中至始至终只有五个名为 “pool-1-thread-1” 到 “pool-1-thread-5” 的五个线程，这五个线程不随着工作的完成而消亡，会一直存在，并负责执行分配给线程池的任务，直到线程池消亡。</p><p>Executors 类提供了使用了 ThreadPoolExecutor 的简单的 ExecutorService 实现，但是 ThreadPoolExecutor 提供的功能远不止于此。我们可以在创建 ThreadPoolExecutor 实例时指定活动线程的数量，我们也可以限制线程池的大小并且创建我们自己的 RejectedExecutionHandler 实现来处理不能适应工作队列的工作。</p><p>这里是我们自定义的 RejectedExecutionHandler 接口的实现。</p><ul><li>RejectedExecutionHandlerImpl.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RejectedExecutionHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">        System.out.println(r.toString() + <span class="string">&quot; is rejected&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor 提供了一些方法，我们可以使用这些方法来查询 executor 的当前状态，线程池大小，活动线程数量以及任务数量。因此我是用来一个监控线程在特定的时间间隔内打印 executor 信息。</p><ul><li>MyMonitorThread.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMonitorThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor executor;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seconds;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> run=<span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyMonitorThread</span><span class="params">(ThreadPoolExecutor executor, <span class="type">int</span> delay)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">        <span class="built_in">this</span>.seconds=delay;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.run=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">                System.out.println(</span><br><span class="line">                    String.format(<span class="string">&quot;[monitor] [%d/%d] Active: %d, Completed: %d, Task: %d, isShutdown: %s, isTerminated: %s&quot;</span>,</span><br><span class="line">                        <span class="built_in">this</span>.executor.getPoolSize(),</span><br><span class="line">                        <span class="built_in">this</span>.executor.getCorePoolSize(),</span><br><span class="line">                        <span class="built_in">this</span>.executor.getActiveCount(),</span><br><span class="line">                        <span class="built_in">this</span>.executor.getCompletedTaskCount(),</span><br><span class="line">                        <span class="built_in">this</span>.executor.getTaskCount(),</span><br><span class="line">                        <span class="built_in">this</span>.executor.isShutdown(),</span><br><span class="line">                        <span class="built_in">this</span>.executor.isTerminated()));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(seconds*<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是使用 ThreadPoolExecutor 的线程池实现例子。</p><ul><li>WorkerPool.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkerPool</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="comment">//RejectedExecutionHandler implementation</span></span><br><span class="line">        <span class="type">RejectedExecutionHandlerImpl</span> <span class="variable">rejectionHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandlerImpl</span>();</span><br><span class="line">        <span class="comment">//Get the ThreadFactory implementation to use</span></span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> Executors.defaultThreadFactory();</span><br><span class="line">        <span class="comment">//creating the ThreadPoolExecutor</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executorPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2</span>), threadFactory, rejectionHandler);</span><br><span class="line">        <span class="comment">//start the monitoring thread</span></span><br><span class="line">        <span class="type">MyMonitorThread</span> <span class="variable">monitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyMonitorThread</span>(executorPool, <span class="number">3</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">monitorThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(monitor);</span><br><span class="line">        monitorThread.start();</span><br><span class="line">        <span class="comment">//submit work to the thread pool</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            executorPool.execute(<span class="keyword">new</span> <span class="title class_">WorkerThread</span>(<span class="string">&quot;cmd&quot;</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">        <span class="comment">//shut down the pool</span></span><br><span class="line">        executorPool.shutdown();</span><br><span class="line">        <span class="comment">//shut down the monitor thread</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        monitor.shutdown();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在初始化 ThreadPoolExecutor 时，我们保持初始池大小为 2，最大池大小为 4 而工作队列大小为 2。因此如果已经有四个正在执行的任务而此时分配来更多任务的话，工作队列将仅仅保留他们(新任务)中的两个，其他的将会被 RejectedExecutionHandlerImpl 处理。</p><p>上面程序的输出可以证实以上观点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1 Start. Command = cmd0</span><br><span class="line">pool-1-thread-4 Start. Command = cmd5</span><br><span class="line">cmd6 is rejected</span><br><span class="line">pool-1-thread-3 Start. Command = cmd4</span><br><span class="line">pool-1-thread-2 Start. Command = cmd1</span><br><span class="line">cmd7 is rejected</span><br><span class="line">cmd8 is rejected</span><br><span class="line">cmd9 is rejected</span><br><span class="line">[monitor] [0/2] Active: 4, Completed: 0, Task: 6, isShutdown: false, isTerminated: false</span><br><span class="line">[monitor] [4/2] Active: 4, Completed: 0, Task: 6, isShutdown: false, isTerminated: false</span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">pool-1-thread-2 End.</span><br><span class="line">pool-1-thread-3 End.</span><br><span class="line">pool-1-thread-1 Start. Command = cmd3</span><br><span class="line">pool-1-thread-4 Start. Command = cmd2</span><br><span class="line">[monitor] [4/2] Active: 2, Completed: 4, Task: 6, isShutdown: false, isTerminated: false</span><br><span class="line">[monitor] [4/2] Active: 2, Completed: 4, Task: 6, isShutdown: false, isTerminated: false</span><br><span class="line">pool-1-thread-1 End.</span><br><span class="line">pool-1-thread-4 End.</span><br><span class="line">[monitor] [4/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false</span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false</span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false</span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false</span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false</span><br><span class="line">[monitor] [2/2] Active: 0, Completed: 6, Task: 6, isShutdown: false, isTerminated: false</span><br><span class="line">[monitor] [0/2] Active: 0, Completed: 6, Task: 6, isShutdown: true, isTerminated: true</span><br><span class="line">[monitor] [0/2] Active: 0, Completed: 6, Task: 6, isShutdown: true, isTerminated: true</span><br></pre></td></tr></table></figure><p>注意 executor 的活动任务、完成任务以及所有完成任务，这些数量上的变化。我们可以调用 shutdown() 方法来结束所有提交的任务并终止线程池。</p><h4 id="ThreadPoolExecutor的原理"><a href="#ThreadPoolExecutor的原理" class="headerlink" title="# ThreadPoolExecutor的原理?"></a><a href="#threadpoolexecutor%E7%9A%84%E5%8E%9F%E7%90%86">#</a> ThreadPoolExecutor的原理?</h4><p>其实java线程池的实现原理很简单，说白了就是一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。</p><p><img src="/images/thread/java-thread-x-executors-1.png" alt="img"></p><p>当一个任务提交至线程池之后:</p><ol><li>线程池首先当前运行的线程数量是否少于corePoolSize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入2.</li><li>判断BlockingQueue是否已经满了，倘若还没有满，则将线程放入BlockingQueue。否则进入3.</li><li>如果创建一个新的工作线程将使当前运行的线程数量超过maximumPoolSize，则交给RejectedExecutionHandler来处理任务。</li></ol><p>当ThreadPoolExecutor创建新线程时，通过CAS来更新线程池的状态ctl.</p><h4 id="ThreadPoolExecutor有哪些核心的配置参数-请简要说明"><a href="#ThreadPoolExecutor有哪些核心的配置参数-请简要说明" class="headerlink" title="# ThreadPoolExecutor有哪些核心的配置参数? 请简要说明"></a><a href="#threadpoolexecutor%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0-%E8%AF%B7%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E">#</a> ThreadPoolExecutor有哪些核心的配置参数? 请简要说明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><ul><li><code>corePoolSize</code> 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize, 即使有其他空闲线程能够执行新来的任务, 也会继续创建线程；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li><li><code>workQueue</code> 用来保存等待被执行的任务的阻塞队列. 在JDK中提供了如下阻塞队列: 具体可以参考<a href>JUC 集合: BlockQueue详解</a><ul><li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按FIFO排序任务；</li><li><code>LinkedBlockingQueue</code>: 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue；</li><li><code>SynchronousQueue</code>: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；</li><li><code>PriorityBlockingQueue</code>: 具有优先级的无界阻塞队列；</li></ul></li></ul><p><code>LinkedBlockingQueue</code>比<code>ArrayBlockingQueue</code>在插入删除节点性能方面更优，但是二者在<code>put()</code>, <code>take()</code>任务的时均需要加锁，<code>SynchronousQueue</code>使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是<code>Transfer.transfer()</code>.</p><ul><li><code>maximumPoolSize </code> 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；当阻塞队列是无界队列, 则maximumPoolSize则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入workQueue.</li><li><code>keepAliveTime </code> 线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用, 超过这个时间的空闲线程将被终止；</li><li><code>unit </code> keepAliveTime的单位</li><li><code>threadFactory </code> 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为DefaultThreadFactory</li><li><code>handler </code> 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:<ul><li><code>AbortPolicy</code>: 直接抛出异常，默认策略；</li><li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</li><li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li><code>DiscardPolicy</code>: 直接丢弃任务；</li></ul></li></ul><p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p><h4 id="ThreadPoolExecutor可以创建哪是哪三种线程池呢"><a href="#ThreadPoolExecutor可以创建哪是哪三种线程池呢" class="headerlink" title="# ThreadPoolExecutor可以创建哪是哪三种线程池呢?"></a><a href="#threadpoolexecutor%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%93%AA%E6%98%AF%E5%93%AA%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%91%A2">#</a> ThreadPoolExecutor可以创建哪是哪三种线程池呢?</h4><ul><li>newFixedThreadPool</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的线程数量达corePoolSize后，即使线程池没有可执行任务时，也不会释放线程。</p><p>FixedThreadPool的工作队列为无界队列LinkedBlockingQueue(队列容量为Integer.MAX_VALUE), 这会导致以下问题:</p><ul><li><p>线程池里的线程数量不超过corePoolSize,这导致了maximumPoolSize和keepAliveTime将会是个无用参数</p></li><li><p>由于使用了无界队列, 所以FixedThreadPool永远不会拒绝, 即饱和策略失效</p></li><li><p>newSingleThreadExecutor</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行.</p><p>由于使用了无界队列, 所以SingleThreadPool永远不会拒绝, 即饱和策略失效</p><ul><li>newCachedThreadPool</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列； 和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销； 执行过程与前两种稍微不同:</p><ul><li>主线程调用SynchronousQueue的offer()方法放入task, 倘若此时线程池中有空闲的线程尝试读取 SynchronousQueue的task, 即调用了SynchronousQueue的poll(), 那么主线程将该task交给空闲线程. 否则执行(2)</li><li>当线程池为空或者没有空闲的线程, 则创建新的线程执行任务.</li><li>执行完任务的线程倘若在60s内仍空闲, 则会被终止. 因此长时间空闲的CachedThreadPool不会持有任何线程资源.</li></ul><h4 id="当队列满了并且worker的数量达到maxSize的时候，会怎么样"><a href="#当队列满了并且worker的数量达到maxSize的时候，会怎么样" class="headerlink" title="# 当队列满了并且worker的数量达到maxSize的时候，会怎么样?"></a><a href="#%E5%BD%93%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E5%B9%B6%E4%B8%94worker%E7%9A%84%E6%95%B0%E9%87%8F%E8%BE%BE%E5%88%B0maxsize%E7%9A%84%E6%97%B6%E5%80%99-%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7">#</a> 当队列满了并且worker的数量达到maxSize的时候，会怎么样?</h4><p>当队列满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br></pre></td></tr></table></figure><h4 id="说说ThreadPoolExecutor有哪些RejectedExecutionHandler策略-默认是什么策略"><a href="#说说ThreadPoolExecutor有哪些RejectedExecutionHandler策略-默认是什么策略" class="headerlink" title="# 说说ThreadPoolExecutor有哪些RejectedExecutionHandler策略? 默认是什么策略?"></a><a href="#%E8%AF%B4%E8%AF%B4threadpoolexecutor%E6%9C%89%E5%93%AA%E4%BA%9Brejectedexecutionhandler%E7%AD%96%E7%95%A5-%E9%BB%98%E8%AE%A4%E6%98%AF%E4%BB%80%E4%B9%88%E7%AD%96%E7%95%A5">#</a> 说说ThreadPoolExecutor有哪些RejectedExecutionHandler策略? 默认是什么策略?</h4><ul><li>AbortPolicy, 默认</li></ul><p>该策略是线程池的默认策略。使用该策略时，如果线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常。 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">  <span class="comment">//不做任何处理，直接抛出异常</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DiscardPolicy</li></ul><p>这个策略和AbortPolicy的slient版本，如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常。 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">    <span class="comment">//就是一个空的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DiscardOldestPolicy</li></ul><p>这个策略从字面上也很好理解，丢弃最老的。也就是说如果队列满了，会将最早进入队列的任务删掉腾出空间，再尝试加入队列。 因为队列是队尾进，队头出，所以队头元素是最老的，因此每次都是移除对头元素后再尝试入队。 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        <span class="comment">//移除队头元素</span></span><br><span class="line">        e.getQueue().poll();</span><br><span class="line">        <span class="comment">//再尝试入队</span></span><br><span class="line">        e.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CallerRunsPolicy</li></ul><p>使用此策略，如果添加到线程池失败，那么主线程会自己去执行该任务，不会等待线程池中的线程去执行。就像是个急脾气的人，我等不到别人来做这件事就干脆自己干。 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        <span class="comment">//直接执行run方法</span></span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简要说下线程池的任务执行机制"><a href="#简要说下线程池的任务执行机制" class="headerlink" title="# 简要说下线程池的任务执行机制?"></a><a href="#%E7%AE%80%E8%A6%81%E8%AF%B4%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6">#</a> 简要说下线程池的任务执行机制?</h4><p>execute –&gt; addWorker –&gt;runworker (getTask)</p><ol><li>线程池的工作线程通过Woker类实现，在ReentrantLock锁的保证下，把Woker实例插入到HashSet后，并启动Woker中的线程。</li><li>从Woker类的构造方法实现可以发现: 线程工厂在创建线程thread时，将Woker实例本身this作为参数传入，当执行start方法启动线程thread时，本质是执行了Worker的runWorker方法。</li><li>firstTask执行完成之后，通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；</li></ol><h4 id="线程池中任务是如何提交的"><a href="#线程池中任务是如何提交的" class="headerlink" title="# 线程池中任务是如何提交的?"></a><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%BB%BB%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E7%9A%84">#</a> 线程池中任务是如何提交的?</h4><p><img src="/images/thread/java-thread-x-executors-3.png" alt="img"></p><ol><li>submit任务，等待线程池execute</li><li>执行FutureTask类的get方法时，会把主线程封装成WaitNode节点并保存在waiters链表中， 并阻塞等待运行结果；</li><li>FutureTask任务执行完成后，通过UNSAFE设置waiters相应的waitNode为null，并通过LockSupport类unpark方法唤醒主线程；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;future result&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际业务场景中，Future和Callable基本是成对出现的，Callable负责产生结果，Future负责获取结果。</p><ol><li>Callable接口类似于Runnable，只是Runnable没有返回值。</li><li>Callable任务除了返回正常结果之外，如果发生异常，该异常也会被返回，即Future可以拿到异步执行任务各种结果；</li><li>Future.get方法会导致主线程阻塞，直到Callable任务执行完成；</li></ol><h4 id="线程池中任务是如何关闭的"><a href="#线程池中任务是如何关闭的" class="headerlink" title="# 线程池中任务是如何关闭的?"></a><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%BB%BB%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E7%9A%84">#</a> 线程池中任务是如何关闭的?</h4><ul><li>shutdown</li></ul><p>将线程池里的线程状态设置成SHUTDOWN状态, 然后中断所有没有正在执行任务的线程.</p><ul><li>shutdownNow</li></ul><p>将线程池里的线程状态设置成STOP状态, 然后停止所有正在执行或暂停任务的线程. 只要调用这两个关闭方法中的任意一个, isShutDown() 返回true. 当所有任务都成功关闭了, isTerminated()返回true.</p><h4 id="在配置线程池的时候需要考虑哪些配置因素"><a href="#在配置线程池的时候需要考虑哪些配置因素" class="headerlink" title="# 在配置线程池的时候需要考虑哪些配置因素?"></a><a href="#%E5%9C%A8%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE%E5%9B%A0%E7%B4%A0">#</a> 在配置线程池的时候需要考虑哪些配置因素?</h4><p>从任务的优先级，任务的执行时间长短，任务的性质(CPU密集/ IO密集)，任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。</p><p>性质不同的任务可用使用不同规模的线程池分开处理:</p><ul><li>CPU密集型: 尽可能少的线程，Ncpu+1</li><li>IO密集型: 尽可能多的线程, Ncpu*2，比如数据库连接池</li><li>混合型: CPU密集型的任务与IO密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。</li></ul><h4 id="如何监控线程池的状态"><a href="#如何监控线程池的状态" class="headerlink" title="# 如何监控线程池的状态?"></a><a href="#%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81">#</a> 如何监控线程池的状态?</h4><p>可以使用ThreadPoolExecutor以下方法:</p><ul><li><code>getTaskCount()</code> Returns the approximate total number of tasks that have ever been scheduled for execution.</li><li><code>getCompletedTaskCount()</code> Returns the approximate total number of tasks that have completed execution. 返回结果少于getTaskCount()。</li><li><code>getLargestPoolSize()</code> Returns the largest number of threads that have ever simultaneously been in the pool. 返回结果小于等于maximumPoolSize</li><li><code>getPoolSize()</code> Returns the current number of threads in the pool.</li><li><code>getActiveCount()</code> Returns the approximate number of threads that are actively executing tasks.</li></ul><h4 id="为什么很多公司不允许使用Executors去创建线程池-那么推荐怎么使用呢"><a href="#为什么很多公司不允许使用Executors去创建线程池-那么推荐怎么使用呢" class="headerlink" title="# 为什么很多公司不允许使用Executors去创建线程池? 那么推荐怎么使用呢?"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E5%85%AC%E5%8F%B8%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8executors%E5%8E%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E9%82%A3%E4%B9%88%E6%8E%A8%E8%8D%90%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%91%A2">#</a> 为什么很多公司不允许使用Executors去创建线程池? 那么推荐怎么使用呢?</h4><p>线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors各个方法的弊端：</p><ul><li>newFixedThreadPool和newSingleThreadExecutor:   主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</li><li>newCachedThreadPool和newScheduledThreadPool:   主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</li><li>推荐方式 1 首先引入：commons-lang3包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BasicThreadFactory</span>.Builder().namingPattern(<span class="string">&quot;example-schedule-pool-%d&quot;</span>).daemon(<span class="literal">true</span>).build());</span><br></pre></td></tr></table></figure><ul><li>推荐方式 2 首先引入：com.google.guava包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">namedThreadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Common Thread Pool</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line"><span class="comment">// excute</span></span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//gracefully shutdown</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure><ul><li>推荐方式 3 spring配置线程池方式：自定义线程工厂bean需要实现ThreadFactory，可参考该接口的其它默认实现类，使用方式直接注入bean调用execute(Runnable task)方法即可</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userThreadPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queueCapacity&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;threadFactory&quot;</span> <span class="attr">value</span>= <span class="string">threadFactory</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//in code</span><br><span class="line">userThreadPool.execute(thread);</span><br></pre></td></tr></table></figure><h4 id="ScheduledThreadPoolExecutor要解决什么样的问题"><a href="#ScheduledThreadPoolExecutor要解决什么样的问题" class="headerlink" title="# ScheduledThreadPoolExecutor要解决什么样的问题?"></a><a href="#scheduledthreadpoolexecutor%E8%A6%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98">#</a> ScheduledThreadPoolExecutor要解决什么样的问题?</h4><p>在很多业务场景中，我们可能需要周期性的运行某项任务来获取结果，比如周期数据统计，定时发送数据等。在并发包出现之前，Java 早在1.3就提供了 Timer 类(只需要了解，目前已渐渐被 ScheduledThreadPoolExecutor 代替)来适应这些业务场景。随着业务量的不断增大，我们可能需要多个工作线程运行任务来尽可能的增加产品性能，或者是需要更高的灵活性来控制和监控这些周期业务。这些都是 ScheduledThreadPoolExecutor 诞生的必然性。</p><h4 id="ScheduledThreadPoolExecutor相比ThreadPoolExecutor有哪些特性"><a href="#ScheduledThreadPoolExecutor相比ThreadPoolExecutor有哪些特性" class="headerlink" title="# ScheduledThreadPoolExecutor相比ThreadPoolExecutor有哪些特性?"></a><a href="#scheduledthreadpoolexecutor%E7%9B%B8%E6%AF%94threadpoolexecutor%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7">#</a> ScheduledThreadPoolExecutor相比ThreadPoolExecutor有哪些特性?</h4><p>ScheduledThreadPoolExecutor继承自 ThreadPoolExecutor，为任务提供延迟或周期执行，属于线程池的一种。和 ThreadPoolExecutor 相比，它还具有以下几种特性:</p><ul><li>使用专门的任务类型—ScheduledFutureTask 来执行周期任务，也可以接收不需要时间调度的任务(这些任务通过 ExecutorService 来执行)。</li><li>使用专门的存储队列—DelayedWorkQueue 来存储任务，DelayedWorkQueue 是无界延迟队列DelayQueue 的一种。相比ThreadPoolExecutor也简化了执行机制(delayedExecute方法，后面单独分析)。</li><li>支持可选的run-after-shutdown参数，在池被关闭(shutdown)之后支持可选的逻辑来决定是否继续运行周期或延迟任务。并且当任务(重新)提交操作与 shutdown 操作重叠时，复查逻辑也不相同。</li></ul><h4 id="ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类"><a href="#ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类" class="headerlink" title="# ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类?"></a><a href="#scheduledthreadpoolexecutor%E6%9C%89%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB">#</a> ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类?</h4><p><img src="/images/thread/java-thread-x-stpe-1.png" alt="img"></p><p>ScheduledThreadPoolExecutor继承自 <code>ThreadPoolExecutor</code>:</p><ul><li>详情请参考: <a href>JUC线程池: ThreadPoolExecutor详解</a></li></ul><p>ScheduledThreadPoolExecutor 内部构造了两个内部类 <code>ScheduledFutureTask</code> 和 <code>DelayedWorkQueue</code>:</p><ul><li><code>ScheduledFutureTask</code>: 继承了FutureTask，说明是一个异步运算任务；最上层分别实现了Runnable、Future、Delayed接口，说明它是一个可以延迟执行的异步运算任务。</li><li><code>DelayedWorkQueue</code>: 这是 ScheduledThreadPoolExecutor 为存储周期或延迟任务专门定义的一个延迟队列，继承了 AbstractQueue，为了契合 ThreadPoolExecutor 也实现了 BlockingQueue 接口。它内部只允许存储 RunnableScheduledFuture 类型的任务。与 DelayQueue 的不同之处就是它只允许存放 RunnableScheduledFuture 对象，并且自己实现了二叉堆(DelayQueue 是利用了 PriorityQueue 的二叉堆结构)。</li></ul><h4 id="ScheduledThreadPoolExecutor有哪两个关闭策略-区别是什么"><a href="#ScheduledThreadPoolExecutor有哪两个关闭策略-区别是什么" class="headerlink" title="# ScheduledThreadPoolExecutor有哪两个关闭策略? 区别是什么?"></a><a href="#scheduledthreadpoolexecutor%E6%9C%89%E5%93%AA%E4%B8%A4%E4%B8%AA%E5%85%B3%E9%97%AD%E7%AD%96%E7%95%A5-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a> ScheduledThreadPoolExecutor有哪两个关闭策略? 区别是什么?</h4><p><strong>shutdown</strong>: 在shutdown方法中调用的关闭钩子onShutdown方法，它的主要作用是在关闭线程池后取消并清除由于关闭策略不应该运行的所有任务，这里主要是根据 run-after-shutdown 参数(continueExistingPeriodicTasksAfterShutdown和executeExistingDelayedTasksAfterShutdown)来决定线程池关闭后是否关闭已经存在的任务。</p><p><strong>showDownNow</strong>: 立即关闭</p><h4 id="ScheduledThreadPoolExecutor中scheduleAtFixedRate-和-scheduleWithFixedDelay区别是什么"><a href="#ScheduledThreadPoolExecutor中scheduleAtFixedRate-和-scheduleWithFixedDelay区别是什么" class="headerlink" title="# ScheduledThreadPoolExecutor中scheduleAtFixedRate 和 scheduleWithFixedDelay区别是什么?"></a><a href="#scheduledthreadpoolexecutor%E4%B8%ADscheduleatfixedrate-%E5%92%8C-schedulewithfixeddelay%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a> ScheduledThreadPoolExecutor中scheduleAtFixedRate 和 scheduleWithFixedDelay区别是什么?</h4><p><strong>注意scheduleAtFixedRate和scheduleWithFixedDelay的区别</strong>: 乍一看两个方法一模一样，其实，在unit.toNanos这一行代码中还是有区别的。没错，scheduleAtFixedRate传的是正值，而scheduleWithFixedDelay传的则是负值，这个值就是 ScheduledFutureTask 的period属性。</p><h4 id="为什么ThreadPoolExecutor-的调整策略却不适用于-ScheduledThreadPoolExecutor"><a href="#为什么ThreadPoolExecutor-的调整策略却不适用于-ScheduledThreadPoolExecutor" class="headerlink" title="# 为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor?"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88threadpoolexecutor-%E7%9A%84%E8%B0%83%E6%95%B4%E7%AD%96%E7%95%A5%E5%8D%B4%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8E-scheduledthreadpoolexecutor">#</a> 为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor?</h4><p>例如: 由于 ScheduledThreadPoolExecutor 是一个固定核心线程数大小的线程池，并且使用了一个无界队列，所以调整maximumPoolSize对其没有任何影响(所以 ScheduledThreadPoolExecutor 没有提供可以调整最大线程数的构造函数，默认最大线程数固定为Integer.MAX_VALUE)。此外，设置corePoolSize为0或者设置核心线程空闲后清除(allowCoreThreadTimeOut)同样也不是一个好的策略，因为一旦周期任务到达某一次运行周期时，可能导致线程池内没有线程去处理这些任务。</p><h4 id="Executors-提供了几种方法来构造-ScheduledThreadPoolExecutor"><a href="#Executors-提供了几种方法来构造-ScheduledThreadPoolExecutor" class="headerlink" title="# Executors 提供了几种方法来构造 ScheduledThreadPoolExecutor?"></a><a href="#executors-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%9D%A5%E6%9E%84%E9%80%A0-scheduledthreadpoolexecutor">#</a> Executors 提供了几种方法来构造 ScheduledThreadPoolExecutor?</h4><ul><li>newScheduledThreadPool: 可指定核心线程数的线程池。</li><li>newSingleThreadScheduledExecutor: 只有一个工作线程的线程池。如果内部工作线程由于执行周期任务异常而被终止，则会新建一个线程替代它的位置。</li></ul><h4 id="Fork-Join主要用来解决什么样的问题"><a href="#Fork-Join主要用来解决什么样的问题" class="headerlink" title="# Fork/Join主要用来解决什么样的问题?"></a><a href="#fork-join%E4%B8%BB%E8%A6%81%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98">#</a> Fork/Join主要用来解决什么样的问题?</h4><p>ForkJoinPool 是JDK 7加入的一个线程池类。Fork/Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。</p><h4 id="Fork-Join框架是在哪个JDK版本中引入的"><a href="#Fork-Join框架是在哪个JDK版本中引入的" class="headerlink" title="# Fork/Join框架是在哪个JDK版本中引入的?"></a><a href="#fork-join%E6%A1%86%E6%9E%B6%E6%98%AF%E5%9C%A8%E5%93%AA%E4%B8%AAjdk%E7%89%88%E6%9C%AC%E4%B8%AD%E5%BC%95%E5%85%A5%E7%9A%84">#</a> Fork/Join框架是在哪个JDK版本中引入的?</h4><p>JDK 7</p><h4 id="Fork-Join框架主要包含哪三个模块-模块之间的关系是怎么样的"><a href="#Fork-Join框架主要包含哪三个模块-模块之间的关系是怎么样的" class="headerlink" title="# Fork/Join框架主要包含哪三个模块? 模块之间的关系是怎么样的?"></a><a href="#fork-join%E6%A1%86%E6%9E%B6%E4%B8%BB%E8%A6%81%E5%8C%85%E5%90%AB%E5%93%AA%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%9D%97-%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">#</a> Fork/Join框架主要包含哪三个模块? 模块之间的关系是怎么样的?</h4><p>Fork/Join框架主要包含三个模块:</p><ul><li>任务对象: <code>ForkJoinTask</code> (包括<code>RecursiveTask</code>、<code>RecursiveAction</code> 和 <code>CountedCompleter</code>)</li><li>执行Fork/Join任务的线程: <code>ForkJoinWorkerThread</code></li><li>线程池: <code>ForkJoinPool</code></li></ul><p>这三者的关系是: ForkJoinPool可以通过池中的ForkJoinWorkerThread来处理ForkJoinTask任务。</p><h4 id="ForkJoinPool类继承关系"><a href="#ForkJoinPool类继承关系" class="headerlink" title="# ForkJoinPool类继承关系?"></a><a href="#forkjoinpool%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB">#</a> ForkJoinPool类继承关系?</h4><p><img src="/images/thread/java-thread-x-forkjoin-1.png" alt="img"></p><p>内部类介绍:</p><ul><li>ForkJoinWorkerThreadFactory: 内部线程工厂接口，用于创建工作线程ForkJoinWorkerThread</li><li>DefaultForkJoinWorkerThreadFactory: ForkJoinWorkerThreadFactory 的默认实现类</li><li>InnocuousForkJoinWorkerThreadFactory: 实现了 ForkJoinWorkerThreadFactory，无许可线程工厂，当系统变量中有系统安全管理相关属性时，默认使用这个工厂创建工作线程。</li><li>EmptyTask: 内部占位类，用于替换队列中 join 的任务。</li><li>ManagedBlocker: 为 ForkJoinPool 中的任务提供扩展管理并行数的接口，一般用在可能会阻塞的任务(如在 Phaser 中用于等待 phase 到下一个generation)。</li><li>WorkQueue: ForkJoinPool 的核心数据结构，本质上是work-stealing 模式的双端任务队列，内部存放 ForkJoinTask 对象任务，使用 @Contented 注解修饰防止伪共享。<ul><li>工作线程在运行中产生新的任务(通常是因为调用了 fork())时，此时可以把 WorkQueue 的数据结构视为一个栈，新的任务会放入栈顶(top 位)；工作线程在处理自己工作队列的任务时，按照 LIFO 的顺序。</li><li>工作线程在处理自己的工作队列同时，会尝试窃取一个任务(可能是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的队列任务)，此时可以把 WorkQueue 的数据结构视为一个 FIFO 的队列，窃取的任务位于其他线程的工作队列的队首(base位)。</li></ul></li><li>伪共享状态: 缓存系统中是以缓存行(cache line)为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</li></ul><h4 id="ForkJoinTask抽象类继承关系"><a href="#ForkJoinTask抽象类继承关系" class="headerlink" title="# ForkJoinTask抽象类继承关系?"></a><a href="#forkjointask%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB">#</a> ForkJoinTask抽象类继承关系?</h4><p><img src="/images/thread/java-thread-x-forkjoin-4.png" alt="img"></p><p>ForkJoinTask 实现了 Future 接口，说明它也是一个可取消的异步运算任务，实际上ForkJoinTask 是 Future 的轻量级实现，主要用在纯粹是计算的函数式任务或者操作完全独立的对象计算任务。fork 是主运行方法，用于异步执行；而 join 方法在任务结果计算完毕之后才会运行，用来合并或返回计算结果。 其内部类都比较简单，ExceptionNode 是用于存储任务执行期间的异常信息的单向链表；其余四个类是为 Runnable/Callable 任务提供的适配器类，用于把 Runnable/Callable 转化为 ForkJoinTask 类型的任务(因为 ForkJoinPool 只可以运行 ForkJoinTask 类型的任务)。</p><h4 id="整个Fork-Join-框架的执行流程-运行机制是怎么样的"><a href="#整个Fork-Join-框架的执行流程-运行机制是怎么样的" class="headerlink" title="# 整个Fork/Join 框架的执行流程/运行机制是怎么样的?"></a><a href="#%E6%95%B4%E4%B8%AAfork-join-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84">#</a> 整个Fork/Join 框架的执行流程/运行机制是怎么样的?</h4><ul><li>首先介绍任务的提交流程 - 外部任务(external/submissions task)提交</li><li>然后介绍任务的提交流程 - 子任务(Worker task)提交</li><li>再分析任务的执行过程(ForkJoinWorkerThread.run()到ForkJoinTask.doExec()这一部分)；</li><li>最后介绍任务的结果获取(ForkJoinTask.join()和ForkJoinTask.invoke())</li></ul><h4 id="具体阐述Fork-Join的分治思想和work-stealing-实现方式"><a href="#具体阐述Fork-Join的分治思想和work-stealing-实现方式" class="headerlink" title="# 具体阐述Fork/Join的分治思想和work-stealing 实现方式?"></a><a href="#%E5%85%B7%E4%BD%93%E9%98%90%E8%BF%B0fork-join%E7%9A%84%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E5%92%8Cwork-stealing-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">#</a> 具体阐述Fork/Join的分治思想和work-stealing 实现方式?</h4><ul><li>分治算法(Divide-and-Conquer)</li></ul><p>分治算法(Divide-and-Conquer)把任务递归的拆分为各个子任务，这样可以更好的利用系统资源，尽可能的使用所有可用的计算能力来提升应用性能。首先看一下 Fork/Join 框架的任务运行机制:</p><p><img src="/images/thread/java-thread-x-forkjoin-2.png" alt="img"></p><ul><li>work-stealing(工作窃取)算法</li></ul><p>work-stealing(工作窃取)算法: 线程池内的所有工作线程都尝试找到并执行已经提交的任务，或者是被其他活动任务创建的子任务(如果不存在就阻塞等待)。这种特性使得 ForkJoinPool 在运行多个可以产生子任务的任务，或者是提交的许多小任务时效率更高。尤其是构建异步模型的 ForkJoinPool 时，对不需要合并(join)的事件类型任务也非常适用。</p><p>在 ForkJoinPool 中，线程池中每个工作线程(ForkJoinWorkerThread)都对应一个任务队列(WorkQueue)，工作线程优先处理来自自身队列的任务(LIFO或FIFO顺序，参数 mode 决定)，然后以FIFO的顺序随机窃取其他队列中的任务。</p><p>具体思路如下:</p><ul><li>每个线程都有自己的一个WorkQueue，该工作队列是一个双端队列。</li><li>队列支持三个功能push、pop、poll</li><li>push/pop只能被队列的所有者线程调用，而poll可以被其他线程调用。</li><li>划分的子任务调用fork时，都会被push到自己的队列中。</li><li>默认情况下，工作线程从自己的双端队列获出任务并执行。</li><li>当自己的队列为空时，线程随机从另一个线程的队列末尾调用poll方法窃取任务。</li></ul><p><img src="/images/thread/java-thread-x-forkjoin-3.png" alt="img"></p><h4 id="有哪些JDK源码中使用了Fork-Join思想"><a href="#有哪些JDK源码中使用了Fork-Join思想" class="headerlink" title="# 有哪些JDK源码中使用了Fork/Join思想?"></a><a href="#%E6%9C%89%E5%93%AA%E4%BA%9Bjdk%E6%BA%90%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86fork-join%E6%80%9D%E6%83%B3">#</a> 有哪些JDK源码中使用了Fork/Join思想?</h4><p>我们常用的数组工具类 Arrays 在JDK 8之后新增的并行排序方法(parallelSort)就运用了 ForkJoinPool 的特性，还有 ConcurrentHashMap 在JDK 8之后添加的函数式方法(如forEach等)也有运用。</p><h4 id="如何使用Executors工具类创建ForkJoinPool"><a href="#如何使用Executors工具类创建ForkJoinPool" class="headerlink" title="# 如何使用Executors工具类创建ForkJoinPool?"></a><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8executors%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%9B%E5%BB%BAforkjoinpool">#</a> 如何使用Executors工具类创建ForkJoinPool?</h4><p>Java8在Executors工具类中新增了两个工厂方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parallelism定义并行级别</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span>;</span><br><span class="line"><span class="comment">// 默认并行级别为JVM可用的处理器个数</span></span><br><span class="line"><span class="comment">// Runtime.getRuntime().availableProcessors()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h4 id="写一个例子-用ForkJoin方式实现1-2-3-…-100000"><a href="#写一个例子-用ForkJoin方式实现1-2-3-…-100000" class="headerlink" title="# 写一个例子: 用ForkJoin方式实现1+2+3+…+100000?"></a><a href="#%E5%86%99%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90-%E7%94%A8forkjoin%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B01-2-3-100000">#</a> 写一个例子: 用ForkJoin方式实现1+2+3+…+100000?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> start; <span class="comment">//开始计算的数</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> end; <span class="comment">//最后计算的数</span></span><br><span class="line"></span><br><span class="line">SumTask(<span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line"><span class="built_in">this</span>.start = start;</span><br><span class="line"><span class="built_in">this</span>.end = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//如果计算量小于1000，那么分配一个线程执行if中的代码块，并返回执行结果</span></span><br><span class="line"><span class="keyword">if</span>(end - start &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行: &quot;</span> + start + <span class="string">&quot;-&quot;</span> + end);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)</span><br><span class="line">sum += i;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果计算量大于1000，那么拆分为两个任务</span></span><br><span class="line"><span class="type">SumTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(start, (start + end) / <span class="number">2</span>);</span><br><span class="line"><span class="type">SumTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>((start + end) / <span class="number">2</span> + <span class="number">1</span>, end);</span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line">task1.fork();</span><br><span class="line">task2.fork();</span><br><span class="line"><span class="comment">//获取任务执行的结果</span></span><br><span class="line"><span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">ForkJoinTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">pool.submit(task);</span><br><span class="line">System.out.println(task.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span> 开始执行: <span class="number">1</span>-<span class="number">625</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">7</span> 开始执行: <span class="number">6251</span>-<span class="number">6875</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">6</span> 开始执行: <span class="number">5626</span>-<span class="number">6250</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">10</span> 开始执行: <span class="number">3751</span>-<span class="number">4375</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">13</span> 开始执行: <span class="number">2501</span>-<span class="number">3125</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">8</span> 开始执行: <span class="number">626</span>-<span class="number">1250</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">11</span> 开始执行: <span class="number">5001</span>-<span class="number">5625</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span> 开始执行: <span class="number">7501</span>-<span class="number">8125</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">14</span> 开始执行: <span class="number">1251</span>-<span class="number">1875</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">4</span> 开始执行: <span class="number">9376</span>-<span class="number">10000</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">8</span> 开始执行: <span class="number">8126</span>-<span class="number">8750</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span> 开始执行: <span class="number">1876</span>-<span class="number">2500</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">12</span> 开始执行: <span class="number">4376</span>-<span class="number">5000</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">5</span> 开始执行: <span class="number">8751</span>-<span class="number">9375</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">7</span> 开始执行: <span class="number">6876</span>-<span class="number">7500</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span> 开始执行: <span class="number">3126</span>-<span class="number">3750</span></span><br><span class="line"><span class="number">50005000</span></span><br></pre></td></tr></table></figure><h4 id="Fork-Join在使用时有哪些注意事项-结合JDK中的斐波那契数列实例具体说明。"><a href="#Fork-Join在使用时有哪些注意事项-结合JDK中的斐波那契数列实例具体说明。" class="headerlink" title="# Fork/Join在使用时有哪些注意事项? 结合JDK中的斐波那契数列实例具体说明。"></a><a href="#fork-join%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-%E7%BB%93%E5%90%88jdk%E4%B8%AD%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%AE%9E%E4%BE%8B%E5%85%B7%E4%BD%93%E8%AF%B4%E6%98%8E%E3%80%82">#</a> Fork/Join在使用时有哪些注意事项? 结合JDK中的斐波那契数列实例具体说明。</h4><p>斐波那契数列: 1、1、2、3、5、8、13、21、34、…… 公式 : F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)(n&gt;=3，n∈N*)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>); <span class="comment">// 最大并发数4</span></span><br><span class="line">    <span class="type">Fibonacci</span> <span class="variable">fibonacci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinPool.invoke(fibonacci);</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下为官方API文档示例</span></span><br><span class="line"><span class="keyword">static</span>  <span class="keyword">class</span> <span class="title class_">Fibonacci</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line">    Fibonacci(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Fibonacci</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>);</span><br><span class="line">        f1.fork(); </span><br><span class="line">        <span class="type">Fibonacci</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> f2.compute() + f1.join(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你也可以两个任务都fork，要注意的是两个任务都fork的情况，必须按照f1.fork()，f2.fork()， f2.join()，f1.join()这样的顺序，不然有性能问题，详见上面注意事项中的说明。</p><p>官方API文档是这样写到的，所以平日用invokeAll就好了。invokeAll会把传入的任务的第一个交给当前线程来执行，其他的任务都fork加入工作队列，这样等于利用当前线程也执行任务了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">Fibonacci</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Fibonacci</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">    invokeAll(f1,f2);</span><br><span class="line">    <span class="keyword">return</span> f2.join() + f1.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeAll</span><span class="params">(ForkJoinTask&lt;?&gt;... tasks)</span> &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> tasks.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> last; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="literal">null</span>)</span><br><span class="line">                ex = <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>)   <span class="comment">//除了第一个都fork</span></span><br><span class="line">            t.fork();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t.doInvoke() &lt; NORMAL &amp;&amp; ex == <span class="literal">null</span>)  <span class="comment">//留一个自己执行</span></span><br><span class="line">            ex = t.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= last; ++i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="literal">null</span>)</span><br><span class="line">                t.cancel(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t.doJoin() &lt; NORMAL)</span><br><span class="line">                ex = t.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="literal">null</span>)</span><br><span class="line">        rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-JUC工具类"><a href="#3-8-JUC工具类" class="headerlink" title="# 3.8 JUC工具类"></a><a href="#_3-8-juc%E5%B7%A5%E5%85%B7%E7%B1%BB">#</a> 3.8 JUC工具类</h3><ul><li><a href>JUC工具类: CountDownLatch详解</a></li><li><a href>JUC工具类: CyclicBarrier详解</a></li><li><a href>JUC工具类: Semaphore详解</a></li><li><a href>JUC工具类: Phaser详解</a></li><li><a href>JUC工具类: Exchanger详解</a></li><li><a href>Java 并发 - ThreadLocal详解</a></li></ul><h4 id="什么是CountDownLatch"><a href="#什么是CountDownLatch" class="headerlink" title="# 什么是CountDownLatch?"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AFcountdownlatch">#</a> 什么是CountDownLatch?</h4><p>CountDownLatch底层也是由AQS，用来同步一个或多个任务的常用并发工具类，强制它们等待由其他任务执行的一组操作完成。</p><h4 id="CountDownLatch底层实现原理"><a href="#CountDownLatch底层实现原理" class="headerlink" title="# CountDownLatch底层实现原理?"></a><a href="#countdownlatch%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">#</a> CountDownLatch底层实现原理?</h4><p>其底层是由AQS提供支持，所以其数据结构可以参考AQS的数据结构，而AQS的数据结构核心就是两个虚拟队列: 同步队列sync queue 和条件队列condition queue，不同的条件会有不同的条件队列。CountDownLatch典型的用法是将一个程序分为n个互相独立的可解决任务，并创建值为n的CountDownLatch。当每一个任务完成时，都会在这个锁存器上调用countDown，等待问题被解决的任务调用这个锁存器的await，将他们自己拦住，直至锁存器计数结束。</p><h4 id="CountDownLatch一次可以唤醒几个任务"><a href="#CountDownLatch一次可以唤醒几个任务" class="headerlink" title="# CountDownLatch一次可以唤醒几个任务?"></a><a href="#countdownlatch%E4%B8%80%E6%AC%A1%E5%8F%AF%E4%BB%A5%E5%94%A4%E9%86%92%E5%87%A0%E4%B8%AA%E4%BB%BB%E5%8A%A1">#</a> CountDownLatch一次可以唤醒几个任务?</h4><p>多个</p><h4 id="CountDownLatch有哪些主要方法"><a href="#CountDownLatch有哪些主要方法" class="headerlink" title="# CountDownLatch有哪些主要方法?"></a><a href="#countdownlatch%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95">#</a> CountDownLatch有哪些主要方法?</h4><p>await(), 此函数将会使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。</p><p>countDown(), 此函数将递减锁存器的计数，如果计数到达零，则释放所有等待的线程</p><h4 id="写道题：实现一个容器，提供两个方法，add，size-写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束"><a href="#写道题：实现一个容器，提供两个方法，add，size-写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束" class="headerlink" title="# 写道题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束?"></a><a href="#%E5%86%99%E9%81%93%E9%A2%98-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8-%E6%8F%90%E4%BE%9B%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95-add-size-%E5%86%99%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B1%E6%B7%BB%E5%8A%A010%E4%B8%AA%E5%85%83%E7%B4%A0%E5%88%B0%E5%AE%B9%E5%99%A8%E4%B8%AD-%E7%BA%BF%E7%A8%8B2%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0-%E5%BD%93%E4%B8%AA%E6%95%B0%E5%88%B05%E4%B8%AA%E6%97%B6-%E7%BA%BF%E7%A8%8B2%E7%BB%99%E5%87%BA%E6%8F%90%E7%A4%BA%E5%B9%B6%E7%BB%93%E6%9D%9F">#</a> 写道题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束?</h4><p>说出使用CountDownLatch 代替wait notify 好处?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用CountDownLatch 代替wait notify 好处是通讯方式简单，不涉及锁定  Count 值为0时当前线程继续执行，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T3</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">volatile</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">T3</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T3</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 start&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(t.getSize() != <span class="number">5</span>)&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   countDownLatch.await();</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2 end&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 start&quot;</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">               t.add(i);</span><br><span class="line">               System.out.println(<span class="string">&quot;add&quot;</span>+ i);</span><br><span class="line">               <span class="keyword">if</span>(t.getSize() == <span class="number">5</span>)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;countdown is open&quot;</span>);</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 end&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是CyclicBarrier"><a href="#什么是CyclicBarrier" class="headerlink" title="# 什么是CyclicBarrier?"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AFcyclicbarrier">#</a> 什么是CyclicBarrier?</h4><ul><li>对于CountDownLatch，其他线程为游戏玩家，比如英雄联盟，主线程为控制游戏开始的线程。在所有的玩家都准备好之前，主线程是处于等待状态的，也就是游戏不能开始。当所有的玩家准备好之后，下一步的动作实施者为主线程，即开始游戏。</li><li>对于CyclicBarrier，假设有一家公司要全体员工进行团建活动，活动内容为翻越三个障碍物，每一个人翻越障碍物所用的时间是不一样的。但是公司要求所有人在翻越当前障碍物之后再开始翻越下一个障碍物，也就是所有人翻越第一个障碍物之后，才开始翻越第二个，以此类推。类比地，每一个员工都是一个“其他线程”。当所有人都翻越的所有的障碍物之后，程序才结束。而主线程可能早就结束了，这里我们不用管主线程。</li></ul><h4 id="CountDownLatch和CyclicBarrier对比"><a href="#CountDownLatch和CyclicBarrier对比" class="headerlink" title="# CountDownLatch和CyclicBarrier对比?"></a><a href="#countdownlatch%E5%92%8Ccyclicbarrier%E5%AF%B9%E6%AF%94">#</a> CountDownLatch和CyclicBarrier对比?</h4><ul><li>CountDownLatch减计数，CyclicBarrier加计数。</li><li>CountDownLatch是一次性的，CyclicBarrier可以重用。</li><li>CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。</li></ul><h4 id="什么是Semaphore"><a href="#什么是Semaphore" class="headerlink" title="# 什么是Semaphore?"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AFsemaphore">#</a> 什么是Semaphore?</h4><p>Semaphore底层是基于AbstractQueuedSynchronizer来实现的。Semaphore称为计数信号量，它允许n个任务同时访问某个资源，可以将信号量看做是在向外分发使用资源的许可证，只有成功获取许可证，才能使用资源</p><h4 id="Semaphore内部原理"><a href="#Semaphore内部原理" class="headerlink" title="# Semaphore内部原理?"></a><a href="#semaphore%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86">#</a> Semaphore内部原理?</h4><p>Semaphore总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。</p><p><img src="/images/thread/java-thread-x-semaphore-1.png" alt="img"></p><p>说明: Semaphore与ReentrantLock的内部类的结构相同，类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。下面逐个进行分析。</p><h4 id="Semaphore常用方法有哪些-如何实现线程同步和互斥的"><a href="#Semaphore常用方法有哪些-如何实现线程同步和互斥的" class="headerlink" title="# Semaphore常用方法有哪些? 如何实现线程同步和互斥的?"></a><a href="#semaphore%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5%E7%9A%84">#</a> Semaphore常用方法有哪些? 如何实现线程同步和互斥的?</h4><h4 id="单独使用Semaphore是不会使用到AQS的条件队列"><a href="#单独使用Semaphore是不会使用到AQS的条件队列" class="headerlink" title="# 单独使用Semaphore是不会使用到AQS的条件队列?"></a><a href="#%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8semaphore%E6%98%AF%E4%B8%8D%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0aqs%E7%9A%84%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97">#</a> 单独使用Semaphore是不会使用到AQS的条件队列?</h4><p>不同于CyclicBarrier和ReentrantLock，单独使用Semaphore是不会使用到AQS的条件队列的，其实，只有进行await操作才会进入条件队列，其他的都是在同步队列中，只是当前线程会被park。</p><h4 id="Semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么"><a href="#Semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么" class="headerlink" title="# Semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?"></a><a href="#semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8910%E4%B8%AA%E4%BB%A4%E7%89%8C-11%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E5%90%84%E8%B0%83%E7%94%A81%E6%AC%A1acquire%E6%96%B9%E6%B3%95-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">#</a> Semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么?</h4><p>拿不到令牌的线程阻塞，不会继续往下运行。</p><h4 id="Semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么"><a href="#Semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么" class="headerlink" title="# Semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?"></a><a href="#semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8910%E4%B8%AA%E4%BB%A4%E7%89%8C-%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%87%8D%E5%A4%8D%E8%B0%83%E7%94%A811%E6%AC%A1acquire%E6%96%B9%E6%B3%95-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">#</a> Semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么?</h4><p>线程阻塞，不会继续往下运行。可能你会考虑类似于锁的重入的问题，很好，但是，令牌没有重入的概念。你只要调用一次acquire方法，就需要有一个令牌才能继续运行。</p><h4 id="Semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗"><a href="#Semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire-2-方法，此线程能够获取到足够的令牌并继续运行吗" class="headerlink" title="# Semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?"></a><a href="#semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%891%E4%B8%AA%E4%BB%A4%E7%89%8C-1%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%80%E6%AC%A1acquire%E6%96%B9%E6%B3%95-%E7%84%B6%E5%90%8E%E8%B0%83%E7%94%A8%E4%B8%A4%E6%AC%A1release%E6%96%B9%E6%B3%95-%E4%B9%8B%E5%90%8E%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8acquire-2-%E6%96%B9%E6%B3%95-%E6%AD%A4%E7%BA%BF%E7%A8%8B%E8%83%BD%E5%A4%9F%E8%8E%B7%E5%8F%96%E5%88%B0%E8%B6%B3%E5%A4%9F%E7%9A%84%E4%BB%A4%E7%89%8C%E5%B9%B6%E7%BB%A7%E7%BB%AD%E8%BF%90%E8%A1%8C%E5%90%97">#</a> Semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗?</h4><p>能，原因是release方法会添加令牌，并不会以初始化的大小为准。</p><h4 id="Semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗"><a href="#Semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗" class="headerlink" title="# Semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?"></a><a href="#semaphore%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%892%E4%B8%AA%E4%BB%A4%E7%89%8C-%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A81%E6%AC%A1release%E6%96%B9%E6%B3%95-%E7%84%B6%E5%90%8E%E4%B8%80%E6%AC%A1%E6%80%A7%E8%8E%B7%E5%8F%963%E4%B8%AA%E4%BB%A4%E7%89%8C-%E4%BC%9A%E8%8E%B7%E5%8F%96%E5%88%B0%E5%90%97">#</a> Semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗?</h4><p>能，原因是release会添加令牌，并不会以初始化的大小为准。Semaphore中release方法的调用并没有限制要在acquire后调用。</p><p>具体示例如下，如果不相信的话，可以运行一下下面的demo，在做实验之前，笔者也认为应该是不允许的。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSemaphore2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">permitsNum</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(permitsNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits:&quot;</span>+semaphore.availablePermits()+<span class="string">&quot;,semaphore.tryAcquire(3,1, TimeUnit.SECONDS):&quot;</span>+semaphore.tryAcquire(<span class="number">3</span>,<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(<span class="string">&quot;availablePermits:&quot;</span>+semaphore.availablePermits()+<span class="string">&quot;,semaphore.tryAcquire(3,1, TimeUnit.SECONDS):&quot;</span>+semaphore.tryAcquire(<span class="number">3</span>,<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Phaser主要用来解决什么问题"><a href="#Phaser主要用来解决什么问题" class="headerlink" title="# Phaser主要用来解决什么问题?"></a><a href="#phaser%E4%B8%BB%E8%A6%81%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">#</a> Phaser主要用来解决什么问题?</h4><p>Phaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。</p><h4 id="Phaser与CyclicBarrier和CountDownLatch的区别是什么"><a href="#Phaser与CyclicBarrier和CountDownLatch的区别是什么" class="headerlink" title="# Phaser与CyclicBarrier和CountDownLatch的区别是什么?"></a><a href="#phaser%E4%B8%8Ecyclicbarrier%E5%92%8Ccountdownlatch%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a> Phaser与CyclicBarrier和CountDownLatch的区别是什么?</h4><p>Phaser 和 CountDownLatch、CyclicBarrier 都有很相似的地方。</p><p>Phaser 顾名思义，就是可以分阶段的进行线程同步。</p><ul><li>CountDownLatch 只能在创建实例时，通过构造方法指定同步数量；</li><li>Phaser 支持线程动态地向它注册。</li></ul><p>利用这个动态注册的特性，可以达到分阶段同步控制的目的：</p><p>注册一批操作，等待它们执行结束；再注册一批操作，等它们结束…</p><h4 id="Phaser运行机制是什么样的"><a href="#Phaser运行机制是什么样的" class="headerlink" title="# Phaser运行机制是什么样的?"></a><a href="#phaser%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84">#</a> Phaser运行机制是什么样的?</h4><p><img src="/images/thread/java-thread-x-juc-phaser-1.png" alt="img"></p><ul><li><strong>Registration(注册)</strong></li></ul><p>跟其他barrier不同，在phaser上注册的parties会随着时间的变化而变化。任务可以随时注册(使用方法register,bulkRegister注册，或者由构造器确定初始parties)，并且在任何抵达点可以随意地撤销注册(方法arriveAndDeregister)。就像大多数基本的同步结构一样，注册和撤销只影响内部count；不会创建更深的内部记录，所以任务不能查询他们是否已经注册。(不过，可以通过继承来实现类似的记录)</p><ul><li><strong>Synchronization(同步机制)</strong></li></ul><p>和CyclicBarrier一样，Phaser也可以重复await。方法arriveAndAwaitAdvance的效果类似CyclicBarrier.await。phaser的每一代都有一个相关的phase number，初始值为0，当所有注册的任务都到达phaser时phase+1，到达最大值(Integer.MAX_VALUE)之后清零。使用phase number可以独立控制 到达phaser 和 等待其他线程 的动作，通过下面两种类型的方法:</p><blockquote><ul><li><strong>Arrival(到达机制)</strong> arrive和arriveAndDeregister方法记录到达状态。这些方法不会阻塞，但是会返回一个相关的arrival phase number；也就是说，phase number用来确定到达状态。当所有任务都到达给定phase时，可以执行一个可选的函数，这个函数通过重写onAdvance方法实现，通常可以用来控制终止状态。重写此方法类似于为CyclicBarrier提供一个barrierAction，但比它更灵活。</li><li><strong>Waiting(等待机制)</strong> awaitAdvance方法需要一个表示arrival phase number的参数，并且在phaser前进到与给定phase不同的phase时返回。和CyclicBarrier不同，即使等待线程已经被中断，awaitAdvance方法也会一直等待。中断状态和超时时间同样可用，但是当任务等待中断或超时后未改变phaser的状态时会遭遇异常。如果有必要，在方法forceTermination之后可以执行这些异常的相关的handler进行恢复操作，Phaser也可能被ForkJoinPool中的任务使用，这样在其他任务阻塞等待一个phase时可以保证足够的并行度来执行任务。</li></ul></blockquote><ul><li><strong>Termination(终止机制)</strong> :</li></ul><p>可以用isTerminated方法检查phaser的终止状态。在终止时，所有同步方法立刻返回一个负值。在终止时尝试注册也没有效果。当调用onAdvance返回true时Termination被触发。当deregistration操作使已注册的parties变为0时，onAdvance的默认实现就会返回true。也可以重写onAdvance方法来定义终止动作。forceTermination方法也可以释放等待线程并且允许它们终止。</p><ul><li><strong>Tiering(分层结构)</strong> :</li></ul><p>Phaser支持分层结构(树状构造)来减少竞争。注册了大量parties的Phaser可能会因为同步竞争消耗很高的成本， 因此可以设置一些子Phaser来共享一个通用的parent。这样的话即使每个操作消耗了更多的开销，但是会提高整体吞吐量。 在一个分层结构的phaser里，子节点phaser的注册和取消注册都通过父节点管理。子节点phaser通过构造或方法register、bulkRegister进行首次注册时，在其父节点上注册。子节点phaser通过调用arriveAndDeregister进行最后一次取消注册时，也在其父节点上取消注册。</p><ul><li><strong>Monitoring(状态监控)</strong> :</li></ul><p>由于同步方法可能只被已注册的parties调用，所以phaser的当前状态也可能被任何调用者监控。在任何时候，可以通过getRegisteredParties获取parties数，其中getArrivedParties方法返回已经到达当前phase的parties数。当剩余的parties(通过方法getUnarrivedParties获取)到达时，phase进入下一代。这些方法返回的值可能只表示短暂的状态，所以一般来说在同步结构里并没有啥卵用。</p><h4 id="给一个Phaser使用的示例"><a href="#给一个Phaser使用的示例" class="headerlink" title="# 给一个Phaser使用的示例?"></a><a href="#%E7%BB%99%E4%B8%80%E4%B8%AAphaser%E4%BD%BF%E7%94%A8%E7%9A%84%E7%A4%BA%E4%BE%8B">#</a> 给一个Phaser使用的示例?</h4><p>模拟了100米赛跑，10名选手，只等裁判一声令下。当所有人都到达终点时，比赛结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Match</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟了100米赛跑，10名选手，只等裁判一声令下。当所有人都到达终点时，比赛结束。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Phaser phaser=<span class="keyword">new</span> <span class="title class_">Phaser</span>(<span class="number">1</span>) ;</span><br><span class="line">        <span class="comment">// 十名选手</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">            phaser.register();</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">player</span>(phaser),<span class="string">&quot;player&quot;</span>+index).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Game Start&quot;</span>);</span><br><span class="line">        <span class="comment">//注销当前线程,比赛开始</span></span><br><span class="line">        phaser.arriveAndDeregister();</span><br><span class="line">        <span class="comment">//是否非终止态一直等待</span></span><br><span class="line">        <span class="keyword">while</span>(!phaser.isTerminated())&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Game Over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">player</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> Phaser phaser ;</span><br><span class="line"></span><br><span class="line">    player(Phaser phaser)&#123;</span><br><span class="line">        <span class="built_in">this</span>.phaser=phaser;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 第一阶段——等待创建好所有线程再开始</span></span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二阶段——等待所有选手准备好再开始</span></span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ready&quot;</span>);</span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第三阶段——等待所有选手准备好到达，到达后，该线程从phaser中注销，不在进行下面的阶段。</span></span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; arrived&quot;</span>);</span><br><span class="line">            phaser.arriveAndDeregister();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Exchanger主要解决什么问题"><a href="#Exchanger主要解决什么问题" class="headerlink" title="# Exchanger主要解决什么问题?"></a><a href="#exchanger%E4%B8%BB%E8%A6%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">#</a> Exchanger主要解决什么问题?</h4><p>Exchanger用于进行两个线程之间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。</p><h4 id="对比SynchronousQueue，为什么说Exchanger可被视为-SynchronousQueue-的双向形式"><a href="#对比SynchronousQueue，为什么说Exchanger可被视为-SynchronousQueue-的双向形式" class="headerlink" title="# 对比SynchronousQueue，为什么说Exchanger可被视为 SynchronousQueue 的双向形式?"></a><a href="#%E5%AF%B9%E6%AF%94synchronousqueue-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4exchanger%E5%8F%AF%E8%A2%AB%E8%A7%86%E4%B8%BA-synchronousqueue-%E7%9A%84%E5%8F%8C%E5%90%91%E5%BD%A2%E5%BC%8F">#</a> 对比SynchronousQueue，为什么说Exchanger可被视为 SynchronousQueue 的双向形式?</h4><p>Exchanger是一种线程间安全交换数据的机制。可以和之前分析过的SynchronousQueue对比一下：线程A通过SynchronousQueue将数据a交给线程B；线程A通过Exchanger和线程B交换数据，线程A把数据a交给线程B，同时线程B把数据b交给线程A。可见，SynchronousQueue是交给一个数据，Exchanger是交换两个数据。</p><h4 id="Exchanger在不同的JDK版本中实现有什么差别"><a href="#Exchanger在不同的JDK版本中实现有什么差别" class="headerlink" title="# Exchanger在不同的JDK版本中实现有什么差别?"></a><a href="#exchanger%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84jdk%E7%89%88%E6%9C%AC%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%88%AB">#</a> Exchanger在不同的JDK版本中实现有什么差别?</h4><ul><li>在JDK5中Exchanger被设计成一个容量为1的容器，存放一个等待线程，直到有另外线程到来就会发生数据交换，然后清空容器，等到下一个到来的线程。</li><li>从JDK6开始，Exchanger用了类似ConcurrentMap的分段思想，提供了多个slot，增加了并发执行时的吞吐量。</li></ul><h4 id="Exchanger实现举例"><a href="#Exchanger实现举例" class="headerlink" title="# Exchanger实现举例"></a><a href="#exchanger%E5%AE%9E%E7%8E%B0%E4%B8%BE%E4%BE%8B">#</a> Exchanger实现举例</h4><p>来一个非常经典的并发问题：你有相同的数据buffer，一个或多个数据生产者，和一个或多个数据消费者。只是Exchange类只能同步2个线程，所以你只能在你的生产者和消费者问题中只有一个生产者和一个消费者时使用这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Exchanger&lt;Integer&gt; exchanger;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Producer(String name, Exchanger&lt;Integer&gt; exchanger) &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="string">&quot;Producer-&quot;</span> + name);</span><br><span class="line">            <span class="built_in">this</span>.exchanger = exchanger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    data = i;</span><br><span class="line">                    System.out.println(getName()+<span class="string">&quot; 交换前:&quot;</span> + data);</span><br><span class="line">                    data = exchanger.exchange(data);</span><br><span class="line">                    System.out.println(getName()+<span class="string">&quot; 交换后:&quot;</span> + data);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Exchanger&lt;Integer&gt; exchanger;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Consumer(String name, Exchanger&lt;Integer&gt; exchanger) &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="string">&quot;Consumer-&quot;</span> + name);</span><br><span class="line">            <span class="built_in">this</span>.exchanger = exchanger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                data = <span class="number">0</span>;</span><br><span class="line">                System.out.println(getName()+<span class="string">&quot; 交换前:&quot;</span> + data);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    data = exchanger.exchange(data);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(getName()+<span class="string">&quot; 交换后:&quot;</span> + data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Exchanger&lt;Integer&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(<span class="string">&quot;&quot;</span>, exchanger).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(<span class="string">&quot;&quot;</span>, exchanger).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其结果可能如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Consumer- 交换前:0</span><br><span class="line">Producer- 交换前:1</span><br><span class="line">Consumer- 交换后:1</span><br><span class="line">Consumer- 交换前:0</span><br><span class="line">Producer- 交换后:0</span><br><span class="line">Producer- 交换前:2</span><br><span class="line">Producer- 交换后:0</span><br><span class="line">Consumer- 交换后:2</span><br><span class="line">Consumer- 交换前:0</span><br><span class="line">Producer- 交换前:3</span><br><span class="line">Producer- 交换后:0</span><br><span class="line">Consumer- 交换后:3</span><br><span class="line">Consumer- 交换前:0</span><br><span class="line">Producer- 交换前:4</span><br><span class="line">Producer- 交换后:0</span><br><span class="line">Consumer- 交换后:4</span><br><span class="line">Consumer- 交换前:0</span><br></pre></td></tr></table></figure><h4 id="什么是ThreadLocal-用来解决什么问题的"><a href="#什么是ThreadLocal-用来解决什么问题的" class="headerlink" title="# 什么是ThreadLocal? 用来解决什么问题的?"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AFthreadlocal-%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E7%9A%84">#</a> 什么是ThreadLocal? 用来解决什么问题的?</h4><p>我们在<a href>Java 并发 - 并发理论基础</a>总结过线程安全(是指广义上的共享资源访问安全性，因为线程隔离是通过副本保证本线程访问资源安全性，它不保证线程之间还存在共享关系的狭义上的安全性)的解决思路：</p><ul><li>互斥同步: synchronized 和 ReentrantLock</li><li>非阻塞同步: CAS, AtomicXXXX</li><li>无同步方案: 栈封闭，本地存储(Thread Local)，可重入代码</li></ul><p>ThreadLocal是通过线程隔离的方式防止任务在共享资源上产生冲突, 线程本地存储是一种自动化机制，可以为使用相同变量的每个不同线程都创建不同的存储。</p><p>ThreadLocal是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用ThreadLocal来维护变量时, ThreadLocal会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。</p><h4 id="说说你对ThreadLocal的理解"><a href="#说说你对ThreadLocal的理解" class="headerlink" title="# 说说你对ThreadLocal的理解"></a><a href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9threadlocal%E7%9A%84%E7%90%86%E8%A7%A3">#</a> 说说你对ThreadLocal的理解</h4><p>提到ThreadLocal被提到应用最多的是session管理和数据库链接管理，这里以数据访问为例帮助你理解ThreadLocal：</p><ul><li>如下数据库管理类在单线程使用是没有任何问题的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">openConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (connect == <span class="literal">null</span>) &#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (connect != <span class="literal">null</span>)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，在多线程中使用会存在线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是共享变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另外一个线程调用closeConnection关闭链接。</p><ul><li>为了解决上述线程安全的问题，第一考虑：互斥同步</li></ul><p>你可能会说，将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理，比如用Synchronized或者ReentrantLock互斥锁。</p><ul><li>这里再抛出一个问题：这地方到底需不需要将connect变量进行共享?</li></ul><p>事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关心其他线程是否对这个connect进行了修改的。即改后的代码可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">openConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (connect == <span class="literal">null</span>) &#123;</span><br><span class="line">            connect = DriverManager.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (connect != <span class="literal">null</span>)</span><br><span class="line">            connect.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConnectionManager</span> <span class="variable">connectionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionManager</span>();</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionManager.openConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用connection进行操作</span></span><br><span class="line"></span><br><span class="line">        connectionManager.closeConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样处理确实也没有任何问题，由于每次都是在方法内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不仅严重影响程序执行效率，还可能导致服务器压力巨大。</p><ul><li>这时候ThreadLocal登场了</li></ul><p>那么这种情况下使用ThreadLocal是再适合不过的了，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。下面就是网上出现最多的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; dbConnectionLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Connection <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> DriverManager.getConnection(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dbConnectionLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ThreadLocal是如何实现线程隔离的"><a href="#ThreadLocal是如何实现线程隔离的" class="headerlink" title="# ThreadLocal是如何实现线程隔离的?"></a><a href="#threadlocal%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E7%9A%84">#</a> ThreadLocal是如何实现线程隔离的?</h4><p>ThreadLocalMap</p><h4 id="为什么ThreadLocal会造成内存泄露-如何解决"><a href="#为什么ThreadLocal会造成内存泄露-如何解决" class="headerlink" title="# 为什么ThreadLocal会造成内存泄露? 如何解决"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88threadlocal%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3">#</a> 为什么ThreadLocal会造成内存泄露? 如何解决</h4><p>网上有这样一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LocalVariable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Long[] a = <span class="keyword">new</span> <span class="title class_">Long</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">poolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, TimeUnit.MINUTES,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;());</span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;LocalVariable&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;LocalVariable&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// (3)</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span> * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">            poolExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// (4)</span></span><br><span class="line">                    localVariable.set(<span class="keyword">new</span> <span class="title class_">LocalVariable</span>());</span><br><span class="line">                    <span class="comment">// (5)</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;use local varaible&quot;</span> + localVariable.get());</span><br><span class="line">                    localVariable.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (6)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pool execute over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用线程池来操作ThreadLocal 对象确实会造成内存泄露, 因为对于线程池里面不会销毁的线程, 里面总会存在着``的强引用, 因为final static 修饰的 ThreadLocal 并不会释放, 而ThreadLocalMap 对于 Key 虽然是弱引用, 但是强引用不会释放, 弱引用当然也会一直有值, 同时创建的LocalVariable对象也不会释放, 就造成了内存泄露; 如果LocalVariable对象不是一个大对象的话, 其实泄露的并不严重, <code>泄露的内存 = 核心线程数 * LocalVariable</code>对象的大小;</p><p>所以, 为了避免出现内存泄露的情况, ThreadLocal提供了一个清除线程中对象的方法, 即 remove, 其实内部实现就是调用 ThreadLocalMap 的remove方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到Key对应的Entry, 并且清除Entry的Key(ThreadLocal)置空, 随后清除过期的Entry即可避免内存泄露。</p><h4 id="还有哪些使用ThreadLocal的应用场景"><a href="#还有哪些使用ThreadLocal的应用场景" class="headerlink" title="# 还有哪些使用ThreadLocal的应用场景?"></a><a href="#%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8threadlocal%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">#</a> 还有哪些使用ThreadLocal的应用场景?</h4><ul><li>每个线程维护了一个“序列号”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerialNum</span> &#123;</span><br><span class="line">    <span class="comment">// The next serial number to be assigned</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextSerialNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ThreadLocal</span> <span class="variable">serialNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(nextSerialNum++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Integer) (serialNum.get())).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ 经典的另外一个例子：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title function_">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException &#123;  </span><br><span class="line">    <span class="type">Session</span> <span class="variable">s</span> <span class="operator">=</span> (Session) threadSession.get();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;  </span><br><span class="line">            s = getSessionFactory().openSession();  </span><br><span class="line">            threadSession.set(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InfrastructureException</span>(ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>看看阿里巴巴 java 开发手册中推荐的 ThreadLocal 的用法:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;DateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> DateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再要用到 DateFormat 对象的地方，这样调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateUtils.df.get().format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure><h1 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h1><blockquote><p>Java IO相关</p></blockquote><h3 id="基础IO"><a href="#基础IO" class="headerlink" title="基础IO"></a>基础IO</h3><h4 id="如何从数据传输方式理解IO流？"><a href="#如何从数据传输方式理解IO流？" class="headerlink" title="如何从数据传输方式理解IO流？"></a>如何从数据传输方式理解IO流？</h4><p>从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:</p><ol><li><strong>字节流</strong>, 字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码中文汉字是 3 个字节，GBK编码中文汉字是 2 个字节。)</li><li><strong>字符流</strong>, 字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</li></ol><p><strong>字节是给计算机看的，字符才是给人看的</strong></p><ul><li><strong>字节流</strong></li></ul><p><img src="/images/io/java-io-category-1.png" alt="img"></p><ul><li><strong>字符流</strong></li></ul><p><img src="/images/io/java-io-category-2.png" alt="img"></p><ul><li><strong>字节转字符</strong>？</li></ul><p><img src="/images/io/java-io-1.png" alt="img"></p><h4 id="如何从数据操作上理解IO流？"><a href="#如何从数据操作上理解IO流？" class="headerlink" title="如何从数据操作上理解IO流？"></a>如何从数据操作上理解IO流？</h4><p>从数据来源或者说是操作对象角度看，IO 类可以分为:</p><p><img src="/images/io/java-io-category-3.png" alt="img"></p><h4 id="Java-IO设计上使用了什么设计模式？"><a href="#Java-IO设计上使用了什么设计模式？" class="headerlink" title="# Java IO设计上使用了什么设计模式？"></a><a href="#java-io%E8%AE%BE%E8%AE%A1%E4%B8%8A%E4%BD%BF%E7%94%A8%E4%BA%86%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">#</a> Java IO设计上使用了什么设计模式？</h4><p><strong>装饰者模式</strong>： 所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。</p><ul><li><strong>装饰者举例</strong></li></ul><p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p><p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p><p><img src="/images/pics/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpg" alt="img"></p><ul><li>以 InputStream 为例<ul><li>InputStream 是抽象组件；</li><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li></ul></li></ul><p><img src="/images/pics/DP-Decorator-java.io.png" alt="image"></p><p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br></pre></td></tr></table></figure><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p><h3 id="5种IO模型"><a href="#5种IO模型" class="headerlink" title="5种IO模型"></a>5种IO模型</h3><h4 id="什么是阻塞？什么是同步？"><a href="#什么是阻塞？什么是同步？" class="headerlink" title="什么是阻塞？什么是同步？"></a>什么是阻塞？什么是同步？</h4><ul><li><strong>阻塞IO 和 非阻塞IO</strong></li></ul><p>这两个概念是<strong>程序级别</strong>的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)</p><ul><li><strong>同步IO 和 非同步IO</strong></li></ul><p>这两个概念是<strong>操作系统级别</strong>的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。</p><h4 id="什么是Linux的IO模型？"><a href="#什么是Linux的IO模型？" class="headerlink" title="什么是Linux的IO模型？"></a>什么是Linux的IO模型？</h4><p>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作。刚才说了，对于一次IO访问（以read举例），<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。所以说，当一个read操作发生时，它会经历两个阶段：</p><ul><li>第一阶段：等待数据准备 (Waiting for the data to be ready)。</li><li>第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。</li></ul><p>对于socket流而言，</p><ul><li>第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li><li>第二步：把数据从内核缓冲区复制到应用进程缓冲区。</li></ul><p>网络应用需要处理的无非就是两大类问题，网络IO，数据计算。相对于后者，网络IO的延迟，给应用带来的性能瓶颈大于后者。网络IO的模型大致有如下几种：</p><ol><li>同步阻塞IO（bloking IO）</li><li>同步非阻塞IO（non-blocking IO）</li><li>多路复用IO（multiplexing IO）</li><li>信号驱动式IO（signal-driven IO）</li><li>异步IO（asynchronous IO）</li></ol><p><img src="/images/io/java-io-compare.png" alt="img"></p><p>PS: 这块略复杂，在后面的提供了问答，所以用了最简单的举例结合Linux IO图例帮你快速理解。@pdai</p><h4 id="什么是同步阻塞IO？"><a href="#什么是同步阻塞IO？" class="headerlink" title="什么是同步阻塞IO？"></a>什么是同步阻塞IO？</h4><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p><ul><li><strong>举例理解</strong></li></ul><p>你早上去买有现炸油条，你点单，之后一直等店家做好，期间你啥其它事也做不了。（你就是应用级别，店家就是操作系统级别， 应用被阻塞了不能做其它事）</p><ul><li><strong>Linux 中IO图例</strong></li></ul><p><img src="/images/io/java-io-model-0.png" alt="img"></p><h4 id="什么是同步非阻塞IO？"><a href="#什么是同步非阻塞IO？" class="headerlink" title="什么是同步非阻塞IO？"></a>什么是同步非阻塞IO？</h4><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。</p><ul><li><strong>举例理解</strong></li></ul><p>你早上去买现炸油条，你点单，点完后每隔一段时间询问店家有没有做好，期间你可以做点其它事情。（你就是应用级别，店家就是操作系统级别，应用可以做其它事情并通过轮询来看操作系统是否完成）</p><ul><li><strong>Linux 中IO图例</strong></li></ul><p><img src="/images/io/java-io-model-1.png" alt="img"></p><h4 id="什么是多路复用IO？"><a href="#什么是多路复用IO？" class="headerlink" title="# 什么是多路复用IO？"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io">#</a> 什么是多路复用IO？</h4><p>系统调用可能是由多个任务组成的，所以可以拆成多个任务，这就是多路复用。</p><ul><li><strong>举例理解</strong></li></ul><p>你早上去买现炸油条，点单收钱和炸油条原来都是由一个人完成的，现在他成了瓶颈，所以专门找了个收银员下单收钱，他则专注在炸油条。（本质上炸油条是耗时的瓶颈，将他职责分离出不是瓶颈的部分，比如下单收银，对应到系统级别也时一样的意思）</p><ul><li><strong>Linux 中IO图例</strong></li></ul><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p><p><img src="/images/io/java-io-model-2.png" alt="img"></p><h4 id="有哪些多路复用IO？"><a href="#有哪些多路复用IO？" class="headerlink" title="有哪些多路复用IO？"></a>有哪些多路复用IO？</h4><p>目前流程的多路复用IO实现主要包括四种: <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>。下表是他们的一些重要特性的比较:</p><table><thead><tr><th>IO模型</th><th>相对性能</th><th>关键思路</th><th>操作系统</th><th>JAVA支持情况</th></tr></thead><tbody><tr><td>select</td><td>较高</td><td>Reactor</td><td>windows/Linux</td><td>支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels 2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型</td></tr><tr><td>poll</td><td>较高</td><td>Reactor</td><td>Linux</td><td>Linux下的JAVA NIO框架，Linux kernels 2.6内核版本之前使用poll进行支持。也是使用的Reactor模式</td></tr><tr><td>epoll</td><td>高</td><td>Reactor/Proactor</td><td>Linux</td><td>Linux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels 2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的 异步IO 支持，所以Linux下使用epoll模拟异步IO</td></tr><tr><td>kqueue</td><td>高</td><td>Proactor</td><td>Linux</td><td>目前JAVA的版本不支持</td></tr></tbody></table><p>多路复用IO技术最适用的是“高并发”场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下多路复用IO技术发挥不出来它的优势。另一方面，使用JAVA NIO进行功能实现，相对于传统的Socket套接字实现要复杂一些，所以实际应用中，需要根据自己的业务需求进行技术选择。</p><h4 id="什么是信号驱动IO？"><a href="#什么是信号驱动IO？" class="headerlink" title="什么是信号驱动IO？"></a>什么是信号驱动IO？</h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p><ul><li><strong>举例理解</strong></li></ul><p>你早上去买现炸油条，门口排队的人多，现在引入了一个叫号系统，点完单后你就可以做自己的事情了，然后等叫号就去拿就可以了。（所以不用再去自己频繁跑去问有没有做好了）</p><ul><li><strong>Linux 中IO图例</strong></li></ul><p><img src="/images/io/java-io-model-3.png" alt="img"></p><h4 id="什么是异步IO？"><a href="#什么是异步IO？" class="headerlink" title="什么是异步IO？"></a>什么是异步IO？</h4><p>相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。</p><ul><li><strong>举例理解</strong></li></ul><p>你早上去买现炸油条， 不用去排队了，打开美团外卖下单，然后做其它事，一会外卖自己送上门。(你就是应用级别，店家就是操作系统级别, 应用无需阻塞，这就是非阻塞；系统还可能在处理中，但是立刻响应了应用，这就是异步)</p><ul><li><strong>Linux 中IO图例</strong></li></ul><p>（Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv）</p><p><img src="/images/io/java-io-model-4.png" alt="img"></p><h4 id="什么是Reactor模型？"><a href="#什么是Reactor模型？" class="headerlink" title="什么是Reactor模型？"></a>什么是Reactor模型？</h4><p>大多数网络框架都是基于Reactor模型进行设计和开发，Reactor模型基于事件驱动，特别适合处理海量的I/O事件。</p><ul><li><strong>传统的IO模型</strong>？</li></ul><p>这种模式是传统设计，每一个请求到来时，大致都会按照：请求读取-&gt;请求解码-&gt;服务执行-&gt;编码响应-&gt;发送答复 这个流程去处理。</p><p><img src="/images/io/java-io-reactor-1.png" alt="img"></p><p>服务器会分配一个线程去处理，如果请求暴涨起来，那么意味着需要更多的线程来处理该请求。若请求出现暴涨，线程池的工作线程数量满载那么其它请求就会出现等待或者被抛弃。若每个小任务都可以使用非阻塞的模式，然后基于异步回调模式。这样就大大提高系统的吞吐量，这便引入了Reactor模型。</p><ul><li><strong>Reactor模型中定义的三种角色</strong>：</li></ul><ol><li><strong>Reactor</strong>：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li><li><strong>Acceptor</strong>：处理客户端新连接，并分派请求到处理器链中。</li><li><strong>Handler</strong>：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理。</li></ol><ul><li><strong>单Reactor单线程模型</strong></li></ul><p>Reactor线程负责多路分离套接字，accept新连接，并分派请求到handler。Redis使用单Reactor单进程的模型。</p><p><img src="/images/io/java-io-reactor-2.png" alt="img"></p><p>消息处理流程：</p><ol><li>Reactor对象通过select监控连接事件，收到事件后通过dispatch进行转发。</li><li>如果是连接建立的事件，则由acceptor接受连接，并创建handler处理后续事件。</li><li>如果不是建立连接事件，则Reactor会分发调用Handler来响应。</li><li>handler会完成read-&gt;业务处理-&gt;send的完整业务流程。</li></ol><ul><li><strong>单Reactor多线程模型</strong></li></ul><p>将handler的处理池化。</p><p><img src="/images/io/java-io-reactor-3.png" alt="img"></p><ul><li><strong>多Reactor多线程模型</strong></li></ul><p>主从Reactor模型： 主Reactor用于响应连接请求，从Reactor用于处理IO操作请求，读写分离了。</p><p><img src="/images/io/java-io-reactor-4.png" alt="img"></p><h4 id="什么是Java-NIO？"><a href="#什么是Java-NIO？" class="headerlink" title="什么是Java NIO？"></a>什么是Java NIO？</h4><p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。<strong>传统IO基于字节流和字符流进行操作</strong>，而<strong>NIO基于Channel和Buffer(缓冲区)进行操作</strong>，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p><p>NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。</p><p><img src="/images/io/java-io-nio-x.png" alt="img"></p><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="传统的IO存在什么问题？为什么引入零拷贝的？"><a href="#传统的IO存在什么问题？为什么引入零拷贝的？" class="headerlink" title="传统的IO存在什么问题？为什么引入零拷贝的？"></a>传统的IO存在什么问题？为什么引入零拷贝的？</h4><p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p><p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p><p>代码通常如下，一般会需要两个系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure><p>代码很简单，虽然就两行代码，但是这里面发生了不少的事情。</p><p><img src="/images/io/java-io-copy-3.png" alt="img"></p><p>首先，<strong>期间共发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 read() ，一次是 write()，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还发生了 <strong>4 次数据拷贝</strong>，其中<strong>两次是 DMA 的拷贝</strong>，另外<strong>两次则是通过 CPU 拷贝</strong>的，下面说一下这个过程：</p><ul><li><strong>第一次拷贝</strong>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li><li><strong>第二次拷贝</strong>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li><strong>第三次拷贝</strong>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li><li><strong>第四次拷贝</strong>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p><p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p><p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</strong>。</p><h4 id="mmap-write怎么实现的零拷贝？"><a href="#mmap-write怎么实现的零拷贝？" class="headerlink" title="mmap + write怎么实现的零拷贝？"></a>mmap + write怎么实现的零拷贝？</h4><p>在前面我们知道，read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure><p>mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p><p><img src="/images/io/java-io-copy-4.png" alt="img"></p><p>具体过程如下：</p><ul><li>应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul><p>我们可以得知，通过使用 mmap() 来代替 read()， 可以减少一次数据拷贝的过程。</p><p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><h4 id="sendfile怎么实现的零拷贝？"><a href="#sendfile怎么实现的零拷贝？" class="headerlink" title="sendfile怎么实现的零拷贝？"></a>sendfile怎么实现的零拷贝？</h4><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 sendfile()，函数形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p><p>首先，它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p><p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p><p><img src="/images/io/java-io-copy-5.png" alt="img"></p><p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（<strong>The Scatter-Gather Direct Memory Access</strong>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p><p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -k eth0 | grep scatter-gather</span><br><span class="line">scatter-gather: on</span><br></pre></td></tr></table></figure><p>于是，从 Linux 内核 2.4 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 系统调用的过程发生了点变化，具体过程如下：</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p><p><img src="/images/io/java-io-copy-6.png" alt="img"></p><p>这就是所谓的<strong>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的</strong>。</p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，<strong>减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运</strong>。</p><h1 id="JVM和调优"><a href="#JVM和调优" class="headerlink" title="JVM和调优"></a>JVM和调优</h1><blockquote><p>JVM虚拟机和调优相关。</p></blockquote><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h4 id="类加载的生命周期？"><a href="#类加载的生命周期？" class="headerlink" title="类加载的生命周期？"></a>类加载的生命周期？</h4><p>其中类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)*。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><img src="/images/jvm/java_jvm_classload_2.png" alt="img"></p><ul><li>类的加载: 查找并加载类的二进制数据</li><li>连接 <ul><li>验证: 确保被加载的类的正确性</li><li>准备: 为类的静态变量分配内存，并将其初始化为默认值</li><li>解析: 把类中的符号引用转换为直接引用</li></ul></li><li>初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</li><li>使用： 类访问方法区内的数据结构的接口， 对象是Heap区的数据</li><li>卸载： 结束生命周期</li></ul><h4 id="类加载器的层次"><a href="#类加载器的层次" class="headerlink" title="类加载器的层次?"></a>类加载器的层次?</h4><p><img src="/images/jvm/java_jvm_classload_3.png" alt="img"></p><ul><li><strong>启动类加载器</strong>: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</li><li><strong>扩展类加载器</strong>: Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</li><li><strong>应用程序类加载器</strong>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li><li><strong>自定义类加载器</strong>: 因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:<ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ul></li></ul><h4 id="Class-forName-和ClassLoader-loadClass-区别"><a href="#Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()区别?"></a>Class.forName()和ClassLoader.loadClass()区别?</h4><ul><li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li></ul><h4 id="JVM有哪些类加载机制？"><a href="#JVM有哪些类加载机制？" class="headerlink" title="JVM有哪些类加载机制？"></a>JVM有哪些类加载机制？</h4><ul><li><strong>JVM类加载机制有哪些</strong>？</li></ul><ol><li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li><li><strong>双亲委派机制</strong>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</li></ol><ul><li><strong>双亲委派机制过程？</strong></li></ul><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li></ol><h3 id="5-2-内存结构"><a href="#5-2-内存结构" class="headerlink" title="5.2 内存结构"></a>5.2 内存结构</h3><h4 id="说说JVM内存整体的结构？线程私有还是共享的？"><a href="#说说JVM内存整体的结构？线程私有还是共享的？" class="headerlink" title="说说JVM内存整体的结构？线程私有还是共享的？"></a>说说JVM内存整体的结构？线程私有还是共享的？</h4><p>JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6fz21n8kj30u00wpn5v.jpg" alt="jvm-framework"></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。</p><ul><li><strong>线程私有</strong>：程序计数器、虚拟机栈、本地方法区</li><li><strong>线程共享</strong>：堆、方法区, 堆外内存（Java7的永久代或JDK8的元空间、代码缓存）</li></ul><h4 id="什么是程序计数器（线程私有）？"><a href="#什么是程序计数器（线程私有）？" class="headerlink" title="什么是程序计数器（线程私有）？"></a>什么是程序计数器（线程私有）？</h4><p>PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p><ul><li><strong>PC寄存器为什么会被设定为线程私有的？</strong></li></ul><p>多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。</p><h4 id="什么是虚拟机栈（线程私有）？"><a href="#什么是虚拟机栈（线程私有）？" class="headerlink" title="什么是虚拟机栈（线程私有）？"></a>什么是虚拟机栈（线程私有）？</h4><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</p><ul><li><strong>特点？</strong></li></ul><ol><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着<strong>入栈</strong>（进栈/压栈），方法执行结束<strong>出栈</strong></li><li>栈不存在垃圾回收问题</li><li>可以通过参数<code>-Xss</code>来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</li></ol><ul><li><strong>该区域有哪些异常</strong>？</li></ul><ol><li>如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 <strong>StackOverflowError</strong> 异常</li><li>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</li></ol><ul><li><strong>栈帧的内部结构？</strong></li></ul><ol><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）(或称为表达式栈)</li><li>动态链接（Dynamic Linking）：指向运行时常量池的方法引用</li><li>方法返回地址（Return Address）：方法正常退出或异常退出的地址</li><li>一些附加信息</li></ol><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc8tjehg8bj318m0lbtbu.jpg" alt="jvm-stack-frame"></p><h4 id="Java虚拟机栈如何进行方法计算的？"><a href="#Java虚拟机栈如何进行方法计算的？" class="headerlink" title="Java虚拟机栈如何进行方法计算的？"></a>Java虚拟机栈如何进行方法计算的？</h4><p>以如下代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过jsclass 等工具查看bytecode</p><p><img src="/images/jvm/java-jvm-stack-2.png" alt="img"></p><p>压栈的步骤如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:   iconst_0 <span class="comment">// 0压栈</span></span><br><span class="line"><span class="number">1</span>:   istore_2 <span class="comment">// 弹出int，存放于局部变量2</span></span><br><span class="line"><span class="number">2</span>:   iload_0  <span class="comment">// 把局部变量0压栈</span></span><br><span class="line"><span class="number">3</span>:   iload_1  <span class="comment">// 局部变量1压栈</span></span><br><span class="line"><span class="number">4</span>:   iadd     <span class="comment">//弹出2个变量，求和，结果压栈</span></span><br><span class="line"><span class="number">5</span>:   istore_2 <span class="comment">//弹出结果，放于局部变量2</span></span><br><span class="line"><span class="number">6</span>:   iload_2  <span class="comment">//局部变量2压栈</span></span><br><span class="line"><span class="number">7</span>:   ireturn  <span class="comment">//返回</span></span><br></pre></td></tr></table></figure><p>如果计算100+98的值，那么操作数栈的变化如下图</p><p><img src="/images/jvm/java-jvm-stack-3.png" alt="img"></p><h4 id="什么是本地方法栈（线程私有）？"><a href="#什么是本地方法栈（线程私有）？" class="headerlink" title="什么是本地方法栈（线程私有）？"></a>什么是本地方法栈（线程私有）？</h4><ul><li><strong>本地方法接口</strong></li></ul><p>一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。</p><ul><li><strong>本地方法栈(Native Method Stack)</strong></li></ul><p>Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用</p><h4 id="什么是方法区（线程共享）？"><a href="#什么是方法区（线程共享）？" class="headerlink" title="什么是方法区（线程共享）？"></a>什么是方法区（线程共享）？</h4><p>方法区（method area）只是 <strong>JVM 规范</strong>中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而**永久代（PermGen）**是 **Hotspot** 虚拟机特有的概念， Java8 的时候又被**元空间**取代了，永久代和元空间都可以理解为方法区的落地实现。</p><p>JDK1.8之前调节方法区大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N //方法区（永久代）初始大小</span><br><span class="line">-XX:MaxPermSize=N //方法区（永久代）最大大小，超出这个值将会抛出OutOfMemoryError </span><br></pre></td></tr></table></figure><p>JDK1.8开始方法区（HotSpot的永久代）被彻底删除了，取而代之的是元空间，元空间直接使用的是本机内存。参数设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N //设置Metaspace的初始（和最小大小）</span><br><span class="line">-XX:MaxMetaspaceSize=N //设置Metaspace的最大大小</span><br></pre></td></tr></table></figure><p><strong>栈、堆、方法区的交互关系</strong></p><p><img src="/images/jvm/java-jvm-stack-1.png" alt="img"></p><h4 id="永久代和元空间内存使用上的差异"><a href="#永久代和元空间内存使用上的差异" class="headerlink" title="永久代和元空间内存使用上的差异?"></a>永久代和元空间内存使用上的差异?</h4><p>Java虚拟机规范中只定义了方法区用于存储已被虚拟机加载的类信息、常量、静态变量和即时编译后的代码等数据</p><ol><li>jdk1.7开始符号引用存储在native heap中，字符串常量和静态类型变量存储在普通的堆区中，但分离的并不彻底,此时永久代中还保存另一些与类的元数据无关的杂项</li><li>jdk8后HotSpot 原永久代中存储的类的<strong>元数据将存储在metaspace</strong>中，而<strong>类的静态变量和字符串常量将放在Java堆中</strong>，metaspace是方法区的一种实现，只不过它使用的不是虚拟机内的内存，而是本地内存。在元空间中保存的数据比永久代中纯粹很多，就只是类的元数据，这些信息只对编译期或JVM的运行时有用。</li><li>永久代有一个JVM本身设置固定大小上线，无法进行调整，而<strong>元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError</strong>。</li><li><strong>符号引用没有存在元空间中，而是存在native heap中</strong>，这是两个方式和位置，不过都可以算作是本地内存，在虚拟机之外进行划分，没有设置限制参数时只受物理内存大小限制，即只有占满了操作系统可用内存后才OOM。</li></ol><h4 id="堆区内存是怎么细分的？"><a href="#堆区内存是怎么细分的？" class="headerlink" title="堆区内存是怎么细分的？"></a>堆区内存是怎么细分的？</h4><p>对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。</p><p>为了进行高效的垃圾回收，虚拟机把堆内存<strong>逻辑上</strong>划分成三块区域（分代的唯一理由就是优化 GC 性能）：</p><ol><li>新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代</li><li>老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdbr7ek6pfj30ci0560t4.jpg" alt="JDK7"></p><p>Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 <code>OutOfMemoryError</code> 异常。</p><ul><li><strong>年轻代 (Young Generation)</strong></li></ul><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 <strong>Minor GC</strong>。年轻一代被分为三个部分——伊甸园（<strong>Eden Memory</strong>）和两个幸存区（<strong>Survivor Memory</strong>，被称为from/to或s0/s1），默认比例是<code>8:1:1</code></p><ol><li>大多数新创建的对象都位于 Eden 内存空间中</li><li>当 Eden 空间被对象填充时，执行<strong>Minor GC</strong>，并将所有幸存者对象移动到一个幸存者空间中</li><li>Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</li><li>经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代</li></ol><ul><li><strong>老年代(Old Generation)</strong></li></ul><p>旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。</p><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gg06065oa9j31kw0u0q69.jpg" alt="img"></p><h4 id="JVM中对象在堆中的生命周期"><a href="#JVM中对象在堆中的生命周期" class="headerlink" title="JVM中对象在堆中的生命周期?"></a>JVM中对象在堆中的生命周期?</h4><ol><li>在 JVM 内存模型的堆中，堆被划分为新生代和老年代 <ul><li>新生代又被进一步划分为 <strong>Eden区</strong> 和 <strong>Survivor区</strong>，Survivor 区由 <strong>From Survivor</strong> 和 <strong>To Survivor</strong> 组成</li></ul></li><li>当创建一个对象时，对象会被优先分配到新生代的 Eden 区 <ul><li>此时 JVM 会给对象定义一个<strong>对象年轻计数器</strong>（<code>-XX:MaxTenuringThreshold</code>）</li></ul></li><li>当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC） <ul><li>JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1</li><li>对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1</li></ul></li><li>如果分配的对象超过了<code>-XX:PetenureSizeThreshold</code>，对象会<strong>直接被分配到老年代</strong></li></ol><h4 id="JVM中对象的分配过程"><a href="#JVM中对象的分配过程" class="headerlink" title="JVM中对象的分配过程?"></a>JVM中对象的分配过程?</h4><p>为对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法和内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li>new 的对象先放在伊甸园区，此区有大小限制</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者 0 区</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区</li><li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区</li><li>什么时候才会去养老区呢？ 默认是 15 次回收标记</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理</li><li>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常</li></ol><h4 id="什么是-TLAB-（Thread-Local-Allocation-Buffer）"><a href="#什么是-TLAB-（Thread-Local-Allocation-Buffer）" class="headerlink" title="什么是 TLAB （Thread Local Allocation Buffer）?"></a>什么是 TLAB （Thread Local Allocation Buffer）?</h4><ul><li>从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内</li><li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为<strong>快速分配策略</strong></li><li>OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计</li></ul><h4 id="为什么要有-TLAB"><a href="#为什么要有-TLAB" class="headerlink" title="为什么要有 TLAB ?"></a>为什么要有 TLAB ?</h4><ul><li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。</p><p>在程序中，可以通过 <code>-XX:UseTLAB</code> 设置是否开启 TLAB 空间。</p><p>默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 <code>-XX:TLABWasteTargetPercent</code> 设置 TLAB 空间所占用 Eden 空间的百分比大小。</p><p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p><h3 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h3><h4 id="如何判断一个对象是否可以回收？"><a href="#如何判断一个对象是否可以回收？" class="headerlink" title="如何判断一个对象是否可以回收？"></a>如何判断一个对象是否可以回收？</h4><ul><li><strong>引用计数算法</strong></li></ul><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p><p>正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><ul><li><strong>可达性分析算法</strong></li></ul><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p><p><img src="/images/pics/0635cbe8.png" alt="image"></p><p>Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h4 id="对象有哪些引用类型？"><a href="#对象有哪些引用类型？" class="headerlink" title="对象有哪些引用类型？"></a>对象有哪些引用类型？</h4><p>无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 具有四种强度不同的引用类型。</p><ul><li><strong>强引用</strong></li></ul><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><ul><li><strong>软引用</strong></li></ul><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><ul><li><strong>弱引用</strong></li></ul><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来实现弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>虚引用</strong></li></ul><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="有哪些基本的垃圾回收算法？"><a href="#有哪些基本的垃圾回收算法？" class="headerlink" title="有哪些基本的垃圾回收算法？"></a>有哪些基本的垃圾回收算法？</h4><ul><li><strong>标记 - 清除</strong></li></ul><p><img src="/images/pics/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg" alt="image"></p><p>将存活的对象进行标记，然后清理掉未被标记的对象。</p><p>不足:</p><ul><li><p>标记和清除过程效率都不高；</p></li><li><p>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</p></li><li><p><strong>标记 - 整理</strong></p></li></ul><p><img src="/images/pics/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg" alt="image"></p><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><ul><li><strong>复制</strong></li></ul><p><img src="/images/pics/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg" alt="image"></p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>主要不足是只使用了内存的一半。</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p><ul><li><strong>分代收集</strong></li></ul><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用: 复制算法</li><li>老年代使用: 标记 - 清除 或者 标记 - 整理 算法</li></ul><h4 id="分代收集算法和分区收集算法区别？"><a href="#分代收集算法和分区收集算法区别？" class="headerlink" title="分代收集算法和分区收集算法区别？"></a>分代收集算法和分区收集算法区别？</h4><p><img src="/images/jvm/cmsgc/cms-gc-5.jpg" alt="img"></p><ul><li><strong>分代收集算法</strong></li></ul><p>当前主流 VM 垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据 对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代，这样就可以根据 各年代特点分别采用最适当的 GC 算法</p><p>在新生代-复制算法：</p><p>每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量 存活对象的复制成本就可以完成收集</p><p>在老年代-标记整理算法：</p><p>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标 记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.</p><ol><li><strong>ParNew</strong>： 一款多线程的收集器，采用复制算法，主要工作在 Young 区，可以通过 <code>-XX:ParallelGCThreads</code> 参数来控制收集的线程数，整个过程都是 STW 的，常与 CMS 组合使用。</li><li><strong>CMS</strong>： 以获取最短回收停顿时间为目标，采用“标记-清除”算法，分 4 大步进行垃圾收集，其中初始标记和重新标记会 STW ，多数应用于互联网站或者 B/S 系统的服务器端上，JDK9 被标记弃用，JDK14 被删除。</li></ol><ul><li><strong>分区收集算法</strong></li></ul><p>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的 好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是 整个堆), 从而减少一次 GC 所产生的停顿。</p><ol><li><strong>G1</strong>： 一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能地满足垃圾收集暂停时间的要求。</li><li><strong>ZGC</strong>： JDK11 中推出的一款低延迟垃圾回收器，适用于大内存低延迟服务的内存管理和回收，SPECjbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。</li></ol><h4 id="什么是Minor-GC、Major-GC、Full-GC"><a href="#什么是Minor-GC、Major-GC、Full-GC" class="headerlink" title="什么是Minor GC、Major GC、Full GC?"></a>什么是Minor GC、Major GC、Full GC?</h4><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： <ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集 <ul><li>目前，只有 CMS GC 会有单独收集老年代的行为</li><li>很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 <ul><li>目前只有 G1 GC 会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</li></ul><h4 id="说说JVM内存分配策略？"><a href="#说说JVM内存分配策略？" class="headerlink" title="说说JVM内存分配策略？"></a>说说JVM内存分配策略？</h4><ul><li><strong>对象优先在 Eden 分配</strong></li></ul><p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p><ul><li><strong>大对象直接进入老年代</strong></li></ul><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p><ul><li><strong>长期存活的对象进入老年代</strong></li></ul><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><ul><li><strong>动态对象年龄判定</strong></li></ul><p>虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><ul><li><strong>空间分配担保</strong></li></ul><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</p><h4 id="什么情况下会触发Full-GC？"><a href="#什么情况下会触发Full-GC？" class="headerlink" title="什么情况下会触发Full GC？"></a>什么情况下会触发Full GC？</h4><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:</p><ul><li><strong>调用 System.gc()</strong></li></ul><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><ul><li><strong>老年代空间不足</strong></li></ul><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><ul><li><strong>空间分配担保失败</strong></li></ul><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p><ul><li><strong>JDK 1.7 及以前的永久代空间不足</strong></li></ul><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><ul><li><strong>Concurrent Mode Failure</strong></li></ul><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h4 id="Hotspot中有哪些垃圾回收器？"><a href="#Hotspot中有哪些垃圾回收器？" class="headerlink" title="Hotspot中有哪些垃圾回收器？"></a>Hotspot中有哪些垃圾回收器？</h4><p><img src="/images/pics/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="image"></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li><li>串行与并行: 串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><ol><li><strong>Serial 收集器</strong></li></ol><p><img src="/images/pics/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" alt="image"></p><p>Serial 翻译为串行，也就是说它以串行的方式执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p><ol><li><strong>ParNew 收集器</strong></li></ol><p><img src="/images/pics/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" alt="image"></p><p>它是 Serial 收集器的多线程版本。</p><p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p><ol><li><strong>Parallel Scavenge 收集器</strong></li></ol><p>与 ParNew 一样是多线程收集器。</p><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>可以通过一个开关参数打开 GC 自适应的调节策略(GC Ergonomics)，就不需要手动指定新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><ol><li><strong>Serial Old 收集器</strong></li></ol><p><img src="/images/pics/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" alt="image"></p><p>是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途:</p><ul><li>在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul><ol><li><strong>Parallel Old 收集器</strong></li></ol><p><img src="/images/pics/278fe431-af88-4a95-a895-9c3b80117de3.jpg" alt="image"></p><p>是 Parallel Scavenge 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><ol><li><strong>CMS 收集器</strong></li></ol><p><img src="/images/pics/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" alt="image"></p><p>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</p><p>分为以下四个流程:</p><ul><li>初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除: 不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点:</p><ul><li>吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><ol><li><strong>G1 收集器</strong></li></ol><p>G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 <strong>G1 可以直接对新生代和老年代一起回收</strong>。</p><p><img src="/images/pics/4cf711a8-7ab2-4152-b85c-d5c226733807.png" alt="image"></p><p>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。</p><p><img src="/images/pics/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="image"></p><p><strong>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收</strong>。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p><img src="/images/pics/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" alt="image"></p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点:</p><ul><li>空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><h4 id="常见的Linux定位问题的工具？"><a href="#常见的Linux定位问题的工具？" class="headerlink" title="常见的Linux定位问题的工具？"></a>常见的Linux定位问题的工具？</h4><ul><li>文本操作 <ul><li>文本查找 - grep</li><li>文本分析 - awk</li><li>文本处理 - sed</li></ul></li><li>文件操作 <ul><li>文件监听 - tail</li><li>文件查找 - find</li></ul></li><li>网络和进程 <ul><li>网络接口 - ifconfig</li><li>防火墙 - iptables -L</li><li>路由表 - route -n</li><li>netstat</li></ul></li><li>其它常用 <ul><li>进程 ps -ef | grep java</li><li>分区大小 df -h</li><li>内存 free -m</li><li>硬盘大小 fdisk -l |grep Disk</li><li>top</li><li>环境变量 env</li></ul></li></ul><h4 id="jps是jdk提供的一个查看当前java进程的小工具，-可以看做是JavaVirtual-Machine-Process-Status-Tool的缩写。"><a href="#jps是jdk提供的一个查看当前java进程的小工具，-可以看做是JavaVirtual-Machine-Process-Status-Tool的缩写。" class="headerlink" title="jps是jdk提供的一个查看当前java进程的小工具， 可以看做是JavaVirtual Machine Process Status Tool的缩写。"></a>jps是jdk提供的一个查看当前java进程的小工具， 可以看做是JavaVirtual Machine Process Status Tool的缩写。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps –l <span class="comment"># 输出输出完全的包名，应用主类名，jar的完全路径名 </span></span><br></pre></td></tr></table></figure><ul><li><strong>jstack</strong> jstack是jdk自带的线程堆栈分析工具，使用该命令可以查看或导出 Java 应用程序中线程堆栈信息。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本</span></span><br><span class="line">jstack 2815</span><br><span class="line">jstack -m 2815 <span class="comment"># java和native c/c++框架的所有栈信息</span></span><br><span class="line">jstack -l 2815 <span class="comment"># 额外的锁信息列表，查看是否死锁</span></span><br></pre></td></tr></table></figure><ul><li><strong>jinfo</strong> jinfo 是 JDK 自带的命令，可以用来查看正在运行的 java 应用程序的扩展参数，包括Java System属性和JVM命令行参数；也可以动态的修改正在运行的 JVM 一些参数。当系统崩溃时，jinfo可以从core文件里面知道崩溃的Java应用程序的配置信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo 2815 <span class="comment"># 输出当前 jvm 进程的全部参数和系统属性</span></span><br></pre></td></tr></table></figure><ul><li><strong>jmap</strong> 命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件， 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看堆的情况</span></span><br><span class="line">jmap -heap 2815</span><br><span class="line"></span><br><span class="line"><span class="comment"># dump</span></span><br><span class="line">jmap -dump:live,format=b,file=/tmp/heap2.bin 2815</span><br></pre></td></tr></table></figure><ul><li><strong>jstat</strong> jstat参数众多，但是使用一个就够了</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 2815 1000 </span><br></pre></td></tr></table></figure><h4 id="如何使用在线调试工具Arthas？"><a href="#如何使用在线调试工具Arthas？" class="headerlink" title="如何使用在线调试工具Arthas？"></a>如何使用在线调试工具Arthas？</h4><p>举几个例子</p><ul><li><strong>查看最繁忙的线程，以及是否有阻塞情况发生</strong>?</li></ul><p>场景：我想看下查看最繁忙的线程，以及是否有阻塞情况发生? 常规查看线程，一般我们可以通过 top 等系统命令进行查看，但是那毕竟要很多个步骤，很麻烦。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread -n 3 <span class="comment"># 查看最繁忙的三个线程栈信息</span></span><br><span class="line">thread  <span class="comment"># 以直观的方式展现所有的线程情况</span></span><br><span class="line">thread -b <span class="comment">#找出当前阻塞其他线程的线程</span></span><br></pre></td></tr></table></figure><ul><li><strong>确认某个类是否已被系统加载</strong>?</li></ul><p>场景：我新写了一个类或者一个方法，我想知道新写的代码是否被部署了?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 即可以找到需要的类全路径，如果存在的话</span></span><br><span class="line">sc *MyServlet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看这个某个类所有的方法</span></span><br><span class="line">sm pdai.tech.servlet.TestMyServlet *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个方法的信息，如果存在的话</span></span><br><span class="line">sm pdai.tech.servlet.TestMyServlet testMethod  </span><br></pre></td></tr></table></figure><ul><li><strong>如何查看一个class类的源码信息</strong>?</li></ul><p>场景：我新修改的内容在方法内部，而上一个步骤只能看到方法，这时候可以反编译看下源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接反编译出java 源代码，包含一此额外信息的</span></span><br><span class="line">jad pdai.tech.servlet.TestMyServlet</span><br></pre></td></tr></table></figure><ul><li><strong>如何跟踪某个方法的返回值、入参</strong>?</li></ul><p>场景：我想看下我新加的方法在线运行的参数和返回值?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时监控入参，返回值，及异常</span></span><br><span class="line">watch pdai.tech.servlet.TestMyServlet testMethod <span class="string">&quot;&#123;params, returnObj, throwExp&#125;&quot;</span> -e -x 2 </span><br></pre></td></tr></table></figure><ul><li><strong>如何看方法调用栈的信息</strong>?</li></ul><p>场景：我想看下某个方法的调用栈的信息?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack pdai.tech.servlet.TestMyServlet testMethod</span><br></pre></td></tr></table></figure><p>运行此命令之后需要即时触发方法才会有响应的信息打印在控制台上</p><ul><li><strong>找到最耗时的方法调用</strong>?</li></ul><p>场景：testMethod这个方法入口响应很慢，如何找到最耗时的子调用?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行的时候每个子调用的运行时长，可以找到最耗时的子调用。</span></span><br><span class="line">stack pdai.tech.servlet.TestMyServlet testMethod</span><br></pre></td></tr></table></figure><p>运行此命令之后需要即时触发方法才会有响应的信息打印在控制台上，然后一层一层看子调用。</p><ul><li><strong>如何临时更改代码运行</strong>?</li></ul><p>场景：我找到了问题所在，能否线上直接修改测试，而不需要在本地改了代码后，重新打包部署，然后重启观察效果?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先反编译出class源码</span></span><br><span class="line">jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后使用外部工具编辑内容</span></span><br><span class="line">mc /tmp/UserController.java -d /tmp  <span class="comment"># 再编译成class</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后，重新载入定义的类，就可以实时验证你的猜测了</span></span><br><span class="line">redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br></pre></td></tr></table></figure><p>如上，是直接更改线上代码的方式，但是一般好像是编译不成功的。所以，最好是本地ide编译成 class文件后，再上传替换为好！</p><p>总之，已经完全不用重启和发布了！这个功能真的很方便，比起重启带来的代价，真的是不可比的。比如，重启时可能导致负载重分配，选主等等问题，就不是你能控制的了。</p><ul><li><strong>我如何测试某个方法的性能问题</strong>?</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor -c 5 demo.MathGame primeFactors</span><br></pre></td></tr></table></figure><h4 id="如何使用Idea的远程调试？"><a href="#如何使用Idea的远程调试？" class="headerlink" title="如何使用Idea的远程调试？"></a>如何使用Idea的远程调试？</h4><p>要让远程服务器运行的代码支持远程调试，则启动的时候必须加上特定的JVM参数，这些参数是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xdebug -Xrunjdwp:transport=dt_socket,<span class="built_in">suspend</span>=n,server=y,address=127.0.0.1:5555</span><br></pre></td></tr></table></figure><h4 id="复杂综合类型问题的定位思路？"><a href="#复杂综合类型问题的定位思路？" class="headerlink" title="复杂综合类型问题的定位思路？"></a>复杂综合类型问题的定位思路？</h4><p><img src="/images/jvm/java-jvm-debug.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-基础&quot;&gt;&lt;a href=&quot;#Java-基础&quot; class=&quot;headerlink&quot; title=&quot;Java 基础&quot;&gt;&lt;/a&gt;Java 基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java基础部分，包括语法基础，泛型，注解，异常，反射和其它（如SPI机制</summary>
      
    
    
    
    
  </entry>
  
</feed>
