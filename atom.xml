<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知识成长记录</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-14T12:40:14.784Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>苏生</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/02/14/%E6%9C%AA%E5%91%BD%E5%90%8D/"/>
    <id>http://example.com/2023/02/14/%E6%9C%AA%E5%91%BD%E5%90%8D/</id>
    <published>2023-02-14T12:40:14.624Z</published>
    <updated>2023-02-14T12:40:14.784Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://example.com/2023/02/13/Redis/"/>
    <id>http://example.com/2023/02/13/Redis/</id>
    <published>2023-02-13T04:48:47.000Z</published>
    <updated>2023-02-14T13:55:53.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是Redis？为什么使用Redis？"><a href="#1、什么是Redis？为什么使用Redis？" class="headerlink" title="1、什么是Redis？为什么使用Redis？"></a>1、什么是Redis？为什么使用Redis？</h2><p>​        Redis是一种支持多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。使用Redis主要有两个用途：高并发和高性能。当然Redis还有作为分布式锁的功能，但这可以 用其他技术代替实现。</p><ul><li><strong>高性能：</strong>我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<strong>更快响应</strong>。</li><li><strong>高并发：</strong>在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用Redis做一个缓冲操作，让请求先访问到Redis，而不是直接访问数据库。</li></ul><h2 id="2、Redis为什么快呢？"><a href="#2、Redis为什么快呢？" class="headerlink" title="2、Redis为什么快呢？"></a>2、Redis为什么快呢？</h2><ul><li><p><strong>完全基于内存操作：可以避免频繁的进行磁盘IO，大大降低响应时间</strong></p><p>MySQL 是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢，每次请求访问数据库时，都存在着 I/O 操作（磁盘IO是很消耗性能的），如果反复频繁的访问数据库，会在数据库中花费过多的时间，并且反复访问数据库会导致数据库的负载过高。</p><p>而 Redis 是基于内存的缓存数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率。</p></li><li><p><strong>使用单线程：避免了线程切换和竞态产生的消耗</strong></p><p>多线程在执行过程中需要进行 CPU 的上下文切换，需要完成一系列工作，这是非常消耗资源的操作，Redis 又是基于内存实现的，对于内存来说，没有上下文切换效率就是最高的。多次读写都在一个CPU 上，对于内存来说就是最佳方案。</p></li><li><p><strong>基于非阻塞的IO多路复用机制</strong></p><p>Redis 采用网络 IO 多路复用技术，来保证在多连接的时候系统的高吞吐量。 多路-指的是多个 socket网络连接，复用-指的是复用一个线程。 采用多路 I/O 复用技术,可以让单个线程高效处理多个连接请求（尽量减少网络 IO 的时间消耗）。并且 Redis 在内存中操作数据的速度非常快（因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈）。</p><p>主要以上两点造就Redis 具有很高的吞吐量。 采用多路 I/O复用技术可以让单个线程高效的处理多个连接请求</p></li><li><p><strong>C语⾔实现，优化过的数据结构，基于⼏种基础的数据结构，Redis做了⼤量的优化，性能极⾼</strong></p><p>MySQL 索引为了提高效率，选择了 B+ 树的数据结构，对于一个应用场景来说合理的数据结构可以让你的应用或者程序更快</p><p>Redis 的底层数据结构一共有6种，分别是简单动态字符串，双向链表，压缩列表，哈希表，跳表和整数数组</p><p>它们和数据类型的对应关系如下图所示：</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230214205104776.png" alt="image-20230214205104776"></p></li></ul><h2 id="3、Redis的线程模型"><a href="#3、Redis的线程模型" class="headerlink" title="3、Redis的线程模型"></a>3、Redis的线程模型</h2><p>Redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。</p><p>它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据socket 上的事件类型来选择对应的事件处理器进行处理。</p><h2 id="4、Redis的常用数据结构及应用场景"><a href="#4、Redis的常用数据结构及应用场景" class="headerlink" title="4、Redis的常用数据结构及应用场景"></a>4、Redis的常用数据结构及应用场景</h2><p>常见的数据结构有: String、Hash、List、Sets、SortSet, 进阶的有HyperLogLog、Geo、Pub/Sub、Streams等</p><ul><li><p>String :  String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p><ul><li>比如缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)等</li></ul></li><li><p>Hash:  这个是类似 map 的一种结构， 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p><ul><li>比如：用户信息、商品信息、文章信息、购物车信息等</li></ul></li><li><p>List:   Redis 中的 List 其实就是链表数据结构的实现。</p><ul><li>应用场景：最新文章、最新动态等（还可以做简陋版的消息队列）</li></ul></li><li><p>Set:   Set 类型是一种无序但都唯一的集合，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p><ul><li>应用场景：实现交集、并集、差集的操作，比如：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景</li><li>应用场景：需要存放的数据不能重复的场景，文章点赞、动态点赞等场景</li></ul></li><li><p>SortSet:  Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。</p><ul><li>应用场景：需要随机获取数据源中的元素根据某个权重进行排序的场景，比如排行榜等</li><li>应用场景：需要存储的数据有优先级或者重要程度的场景 比如优先级任务队列。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、什么是Redis？为什么使用Redis？&quot;&gt;&lt;a href=&quot;#1、什么是Redis？为什么使用Redis？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是Redis？为什么使用Redis？&quot;&gt;&lt;/a&gt;1、什么是Redis？为什么使用Redi</summary>
      
    
    
    
    
  </entry>
  
</feed>
